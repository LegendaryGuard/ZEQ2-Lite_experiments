<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZEQ2-Lite: Locales</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ZEQ2-Lite"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../zeq2lite48x48.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ZEQ2-Lite
   </div>
   <div id="projectbrief">Open-sourced and mod expandable project based on a highly modified ioQuake3 engine foundation and features many true-to-reference DBZ visuals and mechanics. Developer sandbox for people who want to tinker with basic game development.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.php','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d6/d93/group__locales.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Locales</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memItemLeft" align="right" valign="top">namespace std&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d93/group__locales.html#ga544d74b2d5d0dd2197f5fd6f02691de0">_GLIBCXX_VISIBILITY</a> (default)</td></tr>
<tr class="separator:ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes and functions for internationalization and localization.</p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga544d74b2d5d0dd2197f5fd6f02691de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga544d74b2d5d0dd2197f5fd6f02691de0">&#9670;&nbsp;</a></span>_GLIBCXX_VISIBILITY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">namespace std _GLIBCXX_VISIBILITY </td>
          <td>(</td>
          <td class="paramtype">default&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="../../d7/d91/codecvt_8h.html">Tools/MinGW/include/c++/4.6.1/bits/codecvt.h</a>&gt;</code></p>
<p>Empty base class for codecvt facet [22.2.1.5].</p>
<p>Common base for codecvt functions.</p>
<p>This template class provides implementations of the public functions that forward to the protected virtual functions.</p>
<p>This template also provides abstract stubs for the protected virtual functions.</p>
<p>Convert from internal to external character set.</p>
<p>Converts input string of intern_type to output string of extern_type. This is analogous to wcsrtombs. It does this by calling codecvt::do_out.</p>
<p>The source and destination character sets are determined by the facet's locale, internal and external types.</p>
<p>The characters in [from,from_end) are converted and written to [to,to_end). from_next and to_next are set to point to the character following the last successfully converted character, respectively. If the result needed no conversion, from_next and to_next are not affected.</p>
<p>The <em>state</em> argument should be initialized if the input is at the beginning and carried from a previous call if continuing conversion. There are no guarantees about how <em>state</em> is used.</p>
<p>The result returned is a member of codecvt_base::result. If all the input is converted, returns codecvt_base::ok. If no conversion is necessary, returns codecvt_base::noconv. If the input ends early or there is insufficient space in the output, returns codecvt_base::partial. Otherwise the conversion failed and codecvt_base::error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Persistent conversion state data. </td></tr>
    <tr><td class="paramname">from</td><td>Start of input. </td></tr>
    <tr><td class="paramname">from_end</td><td>End of input. </td></tr>
    <tr><td class="paramname">from_next</td><td>Returns start of unconverted data. </td></tr>
    <tr><td class="paramname">to</td><td>Start of output buffer. </td></tr>
    <tr><td class="paramname">to_end</td><td>End of output buffer. </td></tr>
    <tr><td class="paramname">to_next</td><td>Returns start of unused output area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>codecvt_base::result.</dd></dl>
<p>Reset conversion state.</p>
<p>Writes characters to output that would restore <em>state</em> to initial conditions. The idea is that if a partial conversion occurs, then the converting the characters written by this function would leave the state in initial conditions, rather than partial conversion state. It does this by calling codecvt::do_unshift().</p>
<p>For example, if 4 external characters always converted to 1 internal character, and input to <a class="el" href="../../d6/ddb/vm__powerpc_8c.html#a73b4db2550aa2a30b76ff1e7f43cc906">in()</a> had 6 external characters with state saved, this function would write two characters to the output and set the state to initialized conditions.</p>
<p>The source and destination character sets are determined by the facet's locale, internal and external types.</p>
<p>The result returned is a member of codecvt_base::result. If the state could be reset and data written, returns codecvt_base::ok. If no conversion is necessary, returns codecvt_base::noconv. If the output has insufficient space, returns codecvt_base::partial. Otherwise the reset failed and codecvt_base::error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Persistent conversion state data. </td></tr>
    <tr><td class="paramname">to</td><td>Start of output buffer. </td></tr>
    <tr><td class="paramname">to_end</td><td>End of output buffer. </td></tr>
    <tr><td class="paramname">to_next</td><td>Returns start of unused output area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>codecvt_base::result.</dd></dl>
<p>Convert from external to internal character set.</p>
<p>Converts input string of extern_type to output string of intern_type. This is analogous to mbsrtowcs. It does this by calling codecvt::do_in.</p>
<p>The source and destination character sets are determined by the facet's locale, internal and external types.</p>
<p>The characters in [from,from_end) are converted and written to [to,to_end). from_next and to_next are set to point to the character following the last successfully converted character, respectively. If the result needed no conversion, from_next and to_next are not affected.</p>
<p>The <em>state</em> argument should be initialized if the input is at the beginning and carried from a previous call if continuing conversion. There are no guarantees about how <em>state</em> is used.</p>
<p>The result returned is a member of codecvt_base::result. If all the input is converted, returns codecvt_base::ok. If no conversion is necessary, returns codecvt_base::noconv. If the input ends early or there is insufficient space in the output, returns codecvt_base::partial. Otherwise the conversion failed and codecvt_base::error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Persistent conversion state data. </td></tr>
    <tr><td class="paramname">from</td><td>Start of input. </td></tr>
    <tr><td class="paramname">from_end</td><td>End of input. </td></tr>
    <tr><td class="paramname">from_next</td><td>Returns start of unconverted data. </td></tr>
    <tr><td class="paramname">to</td><td>Start of output buffer. </td></tr>
    <tr><td class="paramname">to_end</td><td>End of output buffer. </td></tr>
    <tr><td class="paramname">to_next</td><td>Returns start of unused output area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>codecvt_base::result.</dd></dl>
<p>Convert from internal to external character set.</p>
<p>Converts input string of intern_type to output string of extern_type. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d03/vm__x86__64__assembler_8c.html#a392d7ef877b6258e64850ce3a2647dae">out</a> <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> more information.</dd></dl>
<p>Primary class template codecvt.</p>
<p>NB: Generic, mostly useless implementation.</p>
<p>class codecvt&lt;char, char, mbstate_t&gt; specialization.</p>
<p>class codecvt_byname [22.2.1.6].</p>
<p>Container class for localization functionality.</p>
<p>The locale class is first a class wrapper for C library locales. It is also an extensible container for user-defined localization. A locale is a collection of facets that implement various localization features such as money, time, and number printing.</p>
<p>Constructing C++ locales does not change the C library locale.</p>
<p>This library supports efficient construction and copying of locales through a reference counting implementation of the locale class.</p>
<p>Definition of locale::category.</p>
<p>Category values.</p>
<p>The standard category values are none, ctype, numeric, collate, time, monetary, and messages. They form a bitmask that supports union and intersection. The category all is the union of these values.</p>
<p>NB: Order must match _S_facet_categories definition in locale.cc</p>
<p>Default constructor.</p>
<p>Constructs a copy of the global locale. If no locale has been explicitly set, this is the C locale.</p>
<p>Copy constructor.</p>
<p>Constructs a copy of <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The locale to copy.</td></tr>
  </table>
  </dd>
</dl>
<p>Named locale constructor.</p>
<p>Constructs a copy of the named C library locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Name of the locale to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if s is null or an undefined locale.</td></tr>
  </table>
  </dd>
</dl>
<p>Construct locale with facets from another locale.</p>
<p>Constructs a copy of the locale <em>base</em>. The facets specified by <em>cat</em> are replaced with those from the locale named by <em>s</em>. If base is named, this locale instance will also be named.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The locale to copy. </td></tr>
    <tr><td class="paramname">s</td><td>Name of the locale to use facets from. </td></tr>
    <tr><td class="paramname">cat</td><td>Set of categories defining the facets to use from s. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if s is null or an undefined locale.</td></tr>
  </table>
  </dd>
</dl>
<p>Construct locale with facets from another locale.</p>
<p>Constructs a copy of the locale <em>base</em>. The facets specified by <em>cat</em> are replaced with those from the locale <em>add</em>. If <em>base</em> and <em>add</em> are named, this locale instance will also be named.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The locale to copy. </td></tr>
    <tr><td class="paramname">add</td><td>The locale to use facets from. </td></tr>
    <tr><td class="paramname">cat</td><td>Set of categories defining the facets to use from add.</td></tr>
  </table>
  </dd>
</dl>
<p>Construct locale with another facet.</p>
<p>Constructs a copy of the locale <em>other</em>. The facet @f is added to @other, replacing an existing facet of type Facet if there is one. If @f is null, this locale is a copy of <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The locale to copy. </td></tr>
    <tr><td class="paramname">f</td><td>The facet to add in.</td></tr>
  </table>
  </dd>
</dl>
<p>Locale destructor.</p>
<p>Assignment operator.</p>
<p>Set this locale to be a copy of <em>other</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The locale to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this locale.</dd></dl>
<p>Construct locale with another facet.</p>
<p>Constructs and returns a new copy of this locale. Adds or replaces an existing facet of type Facet from the locale <em>other</em> into the new locale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Facet</td><td>The facet type to copy from other </td></tr>
    <tr><td class="paramname">other</td><td>The locale to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly constructed locale. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if other has no facet of type Facet.</td></tr>
  </table>
  </dd>
</dl>
<p>Return locale name. </p><dl class="section return"><dt>Returns</dt><dd>Locale name or "*" if unnamed.</dd></dl>
<p>Locale equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The locale to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if other and this refer to the same locale instance, are copies, or have the same name. False otherwise.</dd></dl>
<p>Locale inequality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The locale to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>! (*this == other)</dd></dl>
<p>Compare two strings according to collate.</p>
<p>Template operator to compare two strings using the compare function of the collate facet in this locale. One use is to provide the locale to the sort function. For example, a vector v of strings could be sorted according to locale loc by doing: </p><div class="fragment"><div class="line">std::sort(<a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#adfdba28282fbf886223676912be34ab4">v</a>.begin(), <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#adfdba28282fbf886223676912be34ab4">v</a>.end(), loc);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>First string to compare. </td></tr>
    <tr><td class="paramname">s2</td><td>Second string to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if collate&lt;Char&gt; facet compares s1 &lt; s2, else false.</dd></dl>
<p>Set global locale</p>
<p>This function sets the global locale to the argument and returns a copy of the previous global locale. If the argument has a name, it will also call std::setlocale(LC_ALL, loc.name()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locale</td><td>The new locale to make global. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of the old global locale.</dd></dl>
<p>Return reference to the C locale.</p>
<p>Localization functionality base class.</p>
<p>The facet class is the base class for a localization feature, such as money, time, and number printing. It provides common support for facets and reference management.</p>
<p>Facets may not be copied or assigned.</p>
<p>Facet constructor.</p>
<p>This is the constructor provided by the standard. If refs is 0, the facet is destroyed when the last referencing locale is destroyed. Otherwise the facet will never be destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>The initial value for reference count.</td></tr>
  </table>
  </dd>
</dl>
<p>Facet destructor.</p>
<p>Facet ID class.</p>
<p>The ID class provides facets with an index used to identify them. Every facet class must define a public static member locale::id, or be derived from a facet that provides this member, otherwise the facet cannot be used in a locale. The locale::id ensures that each class type gets a unique identifier.</p>
<p>Constructor.</p>
<p>Test for the presence of a facet.</p>
<p>has_facet tests the locale argument for the presence of the facet type provided as the template parameter. Facets derived from the facet parameter will also return true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Facet</td><td>The facet type to test the presence of. </td></tr>
    <tr><td class="paramname">locale</td><td>The locale to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if locale contains a facet of type Facet, else false.</dd></dl>
<p>Return a facet.</p>
<p>use_facet looks for and returns a reference to a facet of type Facet where Facet is the template parameter. If has_facet(locale) is true, there is a suitable facet to return. It throws std::bad_cast if the locale doesn't contain a facet of type Facet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Facet</td><td>The facet type to access. </td></tr>
    <tr><td class="paramname">locale</td><td>The locale to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to facet of type Facet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_cast</td><td>if locale doesn't contain a facet of type Facet.</td></tr>
  </table>
  </dd>
</dl>
<p>Facet for localized string comparison.</p>
<p>This facet encapsulates the code to compare strings in a localized manner.</p>
<p>The collate template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the collate facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Internal constructor. Not for general use.</p>
<p>This is a constructor for use by the library itself to set up new locales.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloc</td><td>The C locale. </td></tr>
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Compare two strings.</p>
<p>This function compares two strings and returns the result by calling collate::do_compare().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo1</td><td>Start of string 1. </td></tr>
    <tr><td class="paramname">hi1</td><td>End of string 1. </td></tr>
    <tr><td class="paramname">lo2</td><td>Start of string 2. </td></tr>
    <tr><td class="paramname">hi2</td><td>End of string 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if string1 &gt; string2, -1 if string1 &lt; string2, else 0.</dd></dl>
<p>Transform string to comparable form.</p>
<p>This function is a wrapper for strxfrm functionality. It takes the input string and returns a modified string that can be directly compared to other transformed strings. In the C locale, this function just returns a copy of the input string. In some other locales, it may replace two chars with one, change a char for another, etc. It does so by returning collate::do_transform().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Start of string. </td></tr>
    <tr><td class="paramname">hi</td><td>End of string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed string_type.</dd></dl>
<p>Return hash of a string.</p>
<p>This function computes and returns a hash on the input string. It does so by returning collate::do_hash().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Start of string. </td></tr>
    <tr><td class="paramname">hi</td><td>End of string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash value.</dd></dl>
<p>Destructor.</p>
<p>Compare two strings.</p>
<p>This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d61/profio_8c.html#a8f4da9bf7cb8d08ceefbc1aadde1969e">compare()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo1</td><td>Start of string 1. </td></tr>
    <tr><td class="paramname">hi1</td><td>End of string 1. </td></tr>
    <tr><td class="paramname">lo2</td><td>Start of string 2. </td></tr>
    <tr><td class="paramname">hi2</td><td>End of string 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if string1 &gt; string2, -1 if string1 &lt; string2, else 0.</dd></dl>
<p>Transform string to comparable form.</p>
<p>This function is a hook for derived classes to change the value returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo1</td><td>Start of string 1. </td></tr>
    <tr><td class="paramname">hi1</td><td>End of string 1. </td></tr>
    <tr><td class="paramname">lo2</td><td>Start of string 2. </td></tr>
    <tr><td class="paramname">hi2</td><td>End of string 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if string1 &gt; string2, -1 if string1 &lt; string2, else 0.</dd></dl>
<p>Return hash of a string.</p>
<p>This function computes and returns a hash on the input string. This function is a hook for derived classes to change the value returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Start of string. </td></tr>
    <tr><td class="paramname">hi</td><td>End of string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash value.</dd></dl>
<p>class collate_byname [22.2.4.2].</p>
<p>Public typedefs</p>
<p>Common base for ctype facet</p>
<p>This template class provides implementations of the public functions that forward to the protected virtual functions.</p>
<p>This template also provides abstract stubs for the protected virtual functions.</p>
<p>Typedef for the template parameter</p>
<p>Test char_type classification.</p>
<p>This function finds a mask M for <em>c</em> and compares it to mask <em>m</em>. It does so by returning the value of ctype&lt;char_type&gt;::do_is().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to compare the mask of. </td></tr>
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(M &amp; m) != 0.</dd></dl>
<p>Return a mask array.</p>
<p>This function finds the mask for each char_type in the range [lo,hi) and successively writes it to vec. vec must have as many elements as the char array. It does so by returning the value of ctype&lt;char_type&gt;::do_is().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">vec</td><td>Pointer to an array of mask storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Find char_type matching a mask</p>
<p>This function searches for and returns the first char_type c in [lo,hi) for which is(m,c) is true. It does so by returning ctype&lt;char_type&gt;::do_scan_is().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to matching char_type if found, else <em>hi</em>.</dd></dl>
<p>Find char_type not matching a mask</p>
<p>This function searches for and returns the first char_type c in [lo,hi) for which is(m,c) is false. It does so by returning ctype&lt;char_type&gt;::do_scan_not().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
    <tr><td class="paramname">lo</td><td>Pointer to first char in range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to non-matching char if found, else <em>hi</em>.</dd></dl>
<p>Convert to uppercase.</p>
<p>This function converts the argument to uppercase if possible. If not possible (for example, '2'), returns the argument. It does so by returning ctype&lt;char_type&gt;::do_toupper().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uppercase char_type if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to uppercase.</p>
<p>This function converts each char_type in the range [lo,hi) to uppercase if possible. Other elements remain untouched. It does so by returning ctype&lt;char_type&gt;:: do_toupper(lo, hi).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Convert to lowercase.</p>
<p>This function converts the argument to lowercase if possible. If not possible (for example, '2'), returns the argument. It does so by returning ctype&lt;char_type&gt;::do_tolower(c).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowercase char_type if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to lowercase.</p>
<p>This function converts each char_type in the range [lo,hi) to lowercase if possible. Other elements remain untouched. It does so by returning ctype&lt;char_type&gt;:: do_tolower(lo, hi).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Widen char to char_type</p>
<p>This function converts the char argument to char_type using the simplest reasonable transformation. It does so by returning ctype&lt;char_type&gt;::do_widen(c).</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted char_type.</dd></dl>
<p>Widen array to char_type</p>
<p>This function converts each char in the input to char_type using the simplest reasonable transformation. It does so by returning ctype&lt;char_type&gt;::do_widen(c).</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Narrow char_type to char</p>
<p>This function converts the char_type to char using the simplest reasonable transformation. If the conversion fails, dfault is returned instead. It does so by returning ctype&lt;char_type&gt;::do_narrow(c).</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to convert. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to return if conversion fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted char.</dd></dl>
<p>Narrow array to char array</p>
<p>This function converts each char_type in the input to char using the simplest reasonable transformation and writes the results to the destination array. For any char_type in the input that cannot be converted, <em>dfault</em> is used instead. It does so by returning ctype&lt;char_type&gt;::do_narrow(lo, hi, dfault, to).</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to use if conversion fails. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Test char_type classification.</p>
<p>This function finds a mask M for <em>c</em> and compares it to mask <em>m</em>.</p>
<p>do_is() is a hook for a derived facet to change the behavior of classifying. do_is() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to find the mask of. </td></tr>
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(M &amp; m) != 0.</dd></dl>
<p>Return a mask array.</p>
<p>This function finds the mask for each char_type in the range [lo,hi) and successively writes it to vec. vec must have as many elements as the input.</p>
<p>do_is() is a hook for a derived facet to change the behavior of classifying. do_is() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">vec</td><td>Pointer to an array of mask storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Find char_type matching mask</p>
<p>This function searches for and returns the first char_type c in [lo,hi) for which is(m,c) is true.</p>
<p>do_scan_is() is a hook for a derived facet to change the behavior of match searching. do_is() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a matching char_type if found, else <em>hi</em>.</dd></dl>
<p>Find char_type not matching mask</p>
<p>This function searches for and returns a pointer to the first char_type c of [lo,hi) for which is(m,c) is false.</p>
<p>do_scan_is() is a hook for a derived facet to change the behavior of match searching. do_is() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a non-matching char_type if found, else <em>hi</em>.</dd></dl>
<p>Convert to uppercase.</p>
<p>This virtual function converts the char_type argument to uppercase if possible. If not possible (for example, '2'), returns the argument.</p>
<p>do_toupper() is a hook for a derived facet to change the behavior of uppercasing. do_toupper() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uppercase char_type if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to uppercase.</p>
<p>This virtual function converts each char_type in the range [lo,hi) to uppercase if possible. Other elements remain untouched.</p>
<p>do_toupper() is a hook for a derived facet to change the behavior of uppercasing. do_toupper() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Convert to lowercase.</p>
<p>This virtual function converts the argument to lowercase if possible. If not possible (for example, '2'), returns the argument.</p>
<p>do_tolower() is a hook for a derived facet to change the behavior of lowercasing. do_tolower() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowercase char_type if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to lowercase.</p>
<p>This virtual function converts each char_type in the range [lo,hi) to lowercase if possible. Other elements remain untouched.</p>
<p>do_tolower() is a hook for a derived facet to change the behavior of lowercasing. do_tolower() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Widen char</p>
<p>This virtual function converts the char to char_type using the simplest reasonable transformation.</p>
<p>do_widen() is a hook for a derived facet to change the behavior of widening. do_widen() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted char_type</dd></dl>
<p>Widen char array</p>
<p>This function converts each char in the input to char_type using the simplest reasonable transformation.</p>
<p>do_widen() is a hook for a derived facet to change the behavior of widening. do_widen() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Narrow char_type to char</p>
<p>This virtual function converts the argument to char using the simplest reasonable transformation. If the conversion fails, dfault is returned instead.</p>
<p>do_narrow() is a hook for a derived facet to change the behavior of narrowing. do_narrow() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char_type to convert. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to return if conversion fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted char.</dd></dl>
<p>Narrow char_type array to char</p>
<p>This virtual function converts each char_type in the range [lo,hi) to char using the simplest reasonable transformation and writes the results to the destination array. For any element in the input that cannot be converted, <em>dfault</em> is used instead.</p>
<p>do_narrow() is a hook for a derived facet to change the behavior of narrowing. do_narrow() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to use if conversion fails. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Primary class template ctype facet.</p>
<p>This template class defines classification and conversion functions for character sets. It wraps cctype functionality. Ctype gets used by streams for many I/O operations.</p>
<p>This template provides the protected virtual functions the developer will have to replace in a derived class or specialization to make a working facet. The public functions that access them are defined in __ctype_abstract_base, to allow for implementation flexibility. See ctype&lt;wchar_t&gt; for an example. The functions are documented in __ctype_abstract_base.</p>
<p>Note: implementations are provided for all the protected virtual functions, but will likely not be useful.</p>
<p>The facet id for ctype&lt;char_type&gt;</p>
<p>The ctype&lt;char&gt; specialization.</p>
<p>This class defines classification and conversion functions for the char type. It gets used by char streams for many I/O operations. The char specialization provides a number of optimizations as well.</p>
<p>Typedef for the template parameter char.</p>
<p>The facet id for ctype&lt;char&gt;</p>
<p>The size of the mask table. It is SCHAR_MAX + 1.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>If non-zero, table is used as the per-char mask. Else classic_table() is used. </td></tr>
    <tr><td class="paramname">del</td><td>If true, passes ownership of table to this facet. </td></tr>
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructor performs static initialization.</p>
<p>This constructor is used to construct the initial C locale facet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloc</td><td>Handle to C locale data. </td></tr>
    <tr><td class="paramname">table</td><td>If non-zero, table is used as the per-char mask. </td></tr>
    <tr><td class="paramname">del</td><td>If true, passes ownership of table to this facet. </td></tr>
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Test char classification.</p>
<p>This function compares the mask table[c] to <em>m</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to compare the mask of. </td></tr>
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if m &amp; table[c] is true, false otherwise.</dd></dl>
<p>Return a mask array.</p>
<p>This function finds the mask for each char in the range [lo, hi) and successively writes it to vec. vec must have as many elements as the char array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">vec</td><td>Pointer to an array of mask storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Find char matching a mask</p>
<p>This function searches for and returns the first char in [lo,hi) for which is(m,char) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a matching char if found, else <em>hi</em>.</dd></dl>
<p>Find char not matching a mask</p>
<p>This function searches for and returns a pointer to the first char in [lo,hi) for which is(m,char) is false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mask to compare against. </td></tr>
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a non-matching char if found, else <em>hi</em>.</dd></dl>
<p>Convert to uppercase.</p>
<p>This function converts the char argument to uppercase if possible. If not possible (for example, '2'), returns the argument.</p>
<p><a class="el" href="../../d7/d0d/ctype_8h.html#aedb9dbcb391f1f20119385596e33406a">toupper()</a> acts as if it returns ctype&lt;char&gt;::do_toupper(c). do_toupper() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uppercase char if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to uppercase.</p>
<p>This function converts each char in the range [lo,hi) to uppercase if possible. Other chars remain untouched.</p>
<p><a class="el" href="../../d7/d0d/ctype_8h.html#aedb9dbcb391f1f20119385596e33406a">toupper()</a> acts as if it returns ctype&lt;char&gt;:: do_toupper(lo, hi). do_toupper() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to first char in range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Convert to lowercase.</p>
<p>This function converts the char argument to lowercase if possible. If not possible (for example, '2'), returns the argument.</p>
<p><a class="el" href="../../d7/d0d/ctype_8h.html#a069e2b5def5e0d999dc07d48dbcafdbf">tolower()</a> acts as if it returns ctype&lt;char&gt;::do_tolower(c). do_tolower() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowercase char if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to lowercase.</p>
<p>This function converts each char in the range [lo,hi) to lowercase if possible. Other chars remain untouched.</p>
<p><a class="el" href="../../d7/d0d/ctype_8h.html#a069e2b5def5e0d999dc07d48dbcafdbf">tolower()</a> acts as if it returns ctype&lt;char&gt;:: do_tolower(lo, hi). do_tolower() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to first char in range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Widen char</p>
<p>This function converts the char to char_type using the simplest reasonable transformation. For an underived ctype&lt;char&gt; facet, the argument will be returned unchanged.</p>
<p>This function works as if it returns ctype&lt;char&gt;::do_widen(c). do_widen() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted character.</dd></dl>
<p>Widen char array</p>
<p>This function converts each char in the input to char using the simplest reasonable transformation. For an underived ctype&lt;char&gt; facet, the argument will be copied unchanged.</p>
<p>This function works as if it returns ctype&lt;char&gt;::do_widen(c). do_widen() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to first char in range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Narrow char</p>
<p>This function converts the char to char using the simplest reasonable transformation. If the conversion fails, dfault is returned instead. For an underived ctype&lt;char&gt; facet, <em>c</em> will be returned unchanged.</p>
<p>This function works as if it returns ctype&lt;char&gt;::do_narrow(c). do_narrow() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to return if conversion fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted character.</dd></dl>
<p>Narrow char array</p>
<p>This function converts each char in the input to char using the simplest reasonable transformation and writes the results to the destination array. For any char in the input that cannot be converted, <em>dfault</em> is used instead. For an underived ctype&lt;char&gt; facet, the argument will be copied unchanged.</p>
<p>This function works as if it returns ctype&lt;char&gt;::do_narrow(lo, hi, dfault, to). do_narrow() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to use if conversion fails. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Returns a pointer to the mask table provided to the constructor, or the default from classic_table() if none was provided.</p>
<p>Returns a pointer to the C locale mask table.</p>
<p>Destructor.</p>
<p>This function deletes <a class="el" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a65df8075f44f790953a8a10f65eba61f">table()</a> if <em>del</em> was true in the constructor.</p>
<p>Convert to uppercase.</p>
<p>This virtual function converts the char argument to uppercase if possible. If not possible (for example, '2'), returns the argument.</p>
<p>do_toupper() is a hook for a derived facet to change the behavior of uppercasing. do_toupper() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The uppercase char if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to uppercase.</p>
<p>This virtual function converts each char in the range [lo,hi) to uppercase if possible. Other chars remain untouched.</p>
<p>do_toupper() is a hook for a derived facet to change the behavior of uppercasing. do_toupper() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Convert to lowercase.</p>
<p>This virtual function converts the char argument to lowercase if possible. If not possible (for example, '2'), returns the argument.</p>
<p>do_tolower() is a hook for a derived facet to change the behavior of lowercasing. do_tolower() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowercase char if convertible, else <em>c</em>.</dd></dl>
<p>Convert array to lowercase.</p>
<p>This virtual function converts each char in the range [lo,hi) to lowercase if possible. Other chars remain untouched.</p>
<p>do_tolower() is a hook for a derived facet to change the behavior of lowercasing. do_tolower() must always return the same result for the same input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to first char in range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Widen char</p>
<p>This virtual function converts the char to char using the simplest reasonable transformation. For an underived ctype&lt;char&gt; facet, the argument will be returned unchanged.</p>
<p>do_widen() is a hook for a derived facet to change the behavior of widening. do_widen() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted character.</dd></dl>
<p>Widen char array</p>
<p>This function converts each char in the range [lo,hi) to char using the simplest reasonable transformation. For an underived ctype&lt;char&gt; facet, the argument will be copied unchanged.</p>
<p>do_widen() is a hook for a derived facet to change the behavior of widening. do_widen() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>Narrow char</p>
<p>This virtual function converts the char to char using the simplest reasonable transformation. If the conversion fails, dfault is returned instead. For an underived ctype&lt;char&gt; facet, <em>c</em> will be returned unchanged.</p>
<p>do_narrow() is a hook for a derived facet to change the behavior of narrowing. do_narrow() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to convert. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to return if conversion fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted char.</dd></dl>
<p>Narrow char array to char array</p>
<p>This virtual function converts each char in the range [lo,hi) to char using the simplest reasonable transformation and writes the results to the destination array. For any char in the input that cannot be converted, <em>dfault</em> is used instead. For an underived ctype&lt;char&gt; facet, the argument will be copied unchanged.</p>
<p>do_narrow() is a hook for a derived facet to change the behavior of narrowing. do_narrow() must always return the same result for the same input.</p>
<p>Note: this is not what you want for codepage conversions. See codecvt for that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Pointer to start of range. </td></tr>
    <tr><td class="paramname">hi</td><td>Pointer to end of range. </td></tr>
    <tr><td class="paramname">dfault</td><td>Char to use if conversion fails. </td></tr>
    <tr><td class="paramname">to</td><td>Pointer to the destination array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>hi</em>.</dd></dl>
<p>class ctype_byname [22.2.1.2].</p>
<p>22.2.1.4 Class ctype_byname specializations.</p>
<p>Primary class template numpunct.</p>
<p>This facet stores several pieces of information related to printing and scanning numbers, such as the decimal point character. It takes a template parameter specifying the char type. The numpunct facet is used by streams for many I/O operations involving numbers.</p>
<p>The numpunct template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from a numpunct facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Numpunct constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Refcount to pass to the base class.</td></tr>
  </table>
  </dd>
</dl>
<p>Internal constructor. Not for general use.</p>
<p>This is a constructor for use by the library itself to set up the predefined locale facets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>__numpunct_cache object. </td></tr>
    <tr><td class="paramname">refs</td><td>Refcount to pass to the base class.</td></tr>
  </table>
  </dd>
</dl>
<p>Internal constructor. Not for general use.</p>
<p>This is a constructor for use by the library itself to set up new locales.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloc</td><td>The C locale. </td></tr>
    <tr><td class="paramname">refs</td><td>Refcount to pass to the base class.</td></tr>
  </table>
  </dd>
</dl>
<p>Return decimal point character.</p>
<p>This function returns a char_type to use as a decimal point. It does so by returning returning numpunct&lt;char_type&gt;::do_decimal_point().</p>
<dl class="section return"><dt>Returns</dt><dd><em>char_type</em> representing a decimal point.</dd></dl>
<p>Return thousands separator character.</p>
<p>This function returns a char_type to use as a thousands separator. It does so by returning returning numpunct&lt;char_type&gt;::do_thousands_sep().</p>
<dl class="section return"><dt>Returns</dt><dd>char_type representing a thousands separator.</dd></dl>
<p>Return grouping specification.</p>
<p>This function returns a string representing groupings for the integer part of a number. Groupings indicate where thousands separators should be inserted in the integer part of a number.</p>
<p>Each char in the return string is interpret as an integer rather than a character. These numbers represent the number of digits in a group. The first char in the string represents the number of digits in the least significant group. If a char is negative, it indicates an unlimited number of digits for the group. If more chars from the string are required to group a number, the last char is used repeatedly.</p>
<p>For example, if the grouping() returns "\003\002" and is applied to the number 123456789, this corresponds to 12,34,56,789. Note that if the string was "32", this would put more than 50 digits into the least significant group if the character set is ASCII.</p>
<p>The string is returned by calling numpunct&lt;char_type&gt;::do_grouping().</p>
<dl class="section return"><dt>Returns</dt><dd>string representing grouping specification.</dd></dl>
<p>Return string representation of bool true.</p>
<p>This function returns a string_type containing the text representation for true bool variables. It does so by calling numpunct&lt;char_type&gt;::do_truename().</p>
<dl class="section return"><dt>Returns</dt><dd>string_type representing printed form of true.</dd></dl>
<p>Return string representation of bool false.</p>
<p>This function returns a string_type containing the text representation for false bool variables. It does so by calling numpunct&lt;char_type&gt;::do_falsename().</p>
<dl class="section return"><dt>Returns</dt><dd>string_type representing printed form of false.</dd></dl>
<p>Destructor.</p>
<p>Return decimal point character.</p>
<p>Returns a char_type to use as a decimal point. This function is a hook for derived classes to change the value returned.</p>
<dl class="section return"><dt>Returns</dt><dd><em>char_type</em> representing a decimal point.</dd></dl>
<p>Return thousands separator character.</p>
<p>Returns a char_type to use as a thousands separator. This function is a hook for derived classes to change the value returned.</p>
<dl class="section return"><dt>Returns</dt><dd><em>char_type</em> representing a thousands separator.</dd></dl>
<p>Return grouping specification.</p>
<p>Returns a string representing groupings for the integer part of a number. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>grouping() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>String representing grouping specification.</dd></dl>
<p>Return string representation of bool true.</p>
<p>Returns a string_type containing the text representation for true bool variables. This function is a hook for derived classes to change the value returned.</p>
<dl class="section return"><dt>Returns</dt><dd>string_type representing printed form of true.</dd></dl>
<p>Return string representation of bool false.</p>
<p>Returns a string_type containing the text representation for false bool variables. This function is a hook for derived classes to change the value returned.</p>
<dl class="section return"><dt>Returns</dt><dd>string_type representing printed form of false.</dd></dl>
<p>class numpunct_byname [22.2.3.2].</p>
<p>Primary class template num_get.</p>
<p>This facet encapsulates the code to parse and return a number from a string. It is used by the istream numeric extraction operators.</p>
<p>The num_get template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the num_get facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Numeric parsing.</p>
<p>Parses the input stream into the bool <em>v</em>. It does so by calling num_get::do_get().</p>
<p>If ios_base::boolalpha is set, attempts to read ctype&lt;CharT&gt;::truename() or ctype&lt;CharT&gt;::falsename(). Sets <em>v</em> to true or false if successful. Sets err to ios_base::failbit if reading the string fails. Sets err to ios_base::eofbit if the stream is emptied.</p>
<p>If ios_base::boolalpha is not set, proceeds as with reading a long, except if the value is 1, sets <em>v</em> to true, if the value is 0, sets <em>v</em> to false, and otherwise set err to ios_base::failbit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Start of input stream. </td></tr>
    <tr><td class="paramname">end</td><td>End of input stream. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after reading.</dd></dl>
<p>Numeric parsing.</p>
<p>Parses the input stream into the integral variable <em>v</em>. It does so by calling num_get::do_get().</p>
<p>Parsing is affected by the flag settings in <em>io</em>.</p>
<p>The basic parse is affected by the value of io.flags() &amp; ios_base::basefield. If equal to ios_base::oct, parses like the scanf o specifier. Else if equal to ios_base::hex, parses like X specifier. Else if basefield equal to 0, parses like the i specifier. Otherwise, parses like d for signed and u for unsigned types. The matching type length modifier is also used.</p>
<p>Digit grouping is interpreted according to numpunct::grouping() and numpunct::thousands_sep(). If the pattern of digit groups isn't consistent, sets err to ios_base::failbit.</p>
<p>If parsing the string yields a valid value for <em>v</em>, <em>v</em> is set. Otherwise, sets err to ios_base::failbit and leaves <em>v</em> unaltered. Sets err to ios_base::eofbit if the stream is emptied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Start of input stream. </td></tr>
    <tr><td class="paramname">end</td><td>End of input stream. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after reading.</dd></dl>
<p>Numeric parsing.</p>
<p>Parses the input stream into the integral variable <em>v</em>. It does so by calling num_get::do_get().</p>
<p>The input characters are parsed like the scanf g specifier. The matching type length modifier is also used.</p>
<p>The decimal point character used is numpunct::decimal_point(). Digit grouping is interpreted according to numpunct::grouping() and numpunct::thousands_sep(). If the pattern of digit groups isn't consistent, sets err to ios_base::failbit.</p>
<p>If parsing the string yields a valid value for <em>v</em>, <em>v</em> is set. Otherwise, sets err to ios_base::failbit and leaves <em>v</em> unaltered. Sets err to ios_base::eofbit if the stream is emptied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Start of input stream. </td></tr>
    <tr><td class="paramname">end</td><td>End of input stream. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after reading.</dd></dl>
<p>Numeric parsing.</p>
<p>Parses the input stream into the pointer variable <em>v</em>. It does so by calling num_get::do_get().</p>
<p>The input characters are parsed like the scanf p specifier.</p>
<p>Digit grouping is interpreted according to numpunct::grouping() and numpunct::thousands_sep(). If the pattern of digit groups isn't consistent, sets err to ios_base::failbit.</p>
<p>Note that the digit grouping effect for pointers is a bit ambiguous in the standard and shouldn't be relied on. See DR 344.</p>
<p>If parsing the string yields a valid value for <em>v</em>, <em>v</em> is set. Otherwise, sets err to ios_base::failbit and leaves <em>v</em> unaltered. Sets err to ios_base::eofbit if the stream is emptied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Start of input stream. </td></tr>
    <tr><td class="paramname">end</td><td>End of input stream. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after reading.</dd></dl>
<p>Destructor.</p>
<p>Numeric parsing.</p>
<p>Parses the input stream into the variable <em>v</em>. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d7f/gram_8c.html#a3ce4e86bf8e816c7d7bd993acfa107fe">get()</a> <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Start of input stream. </td></tr>
    <tr><td class="paramname">end</td><td>End of input stream. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after reading.</dd></dl>
<p>Primary class template num_put.</p>
<p>This facet encapsulates the code to convert a number to a string. It is used by the ostream numeric insertion operators.</p>
<p>The num_put template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the num_put facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Numeric formatting.</p>
<p>Formats the boolean <em>v</em> and inserts it into a stream. It does so by calling num_put::do_put().</p>
<p>If ios_base::boolalpha is set, writes ctype&lt;CharT&gt;::truename() or ctype&lt;CharT&gt;::falsename(). Otherwise formats <em>v</em> as an int.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">fill</td><td>Char_type to use for filling. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Numeric formatting.</p>
<p>Formats the integral value <em>v</em> and inserts it into a stream. It does so by calling num_put::do_put().</p>
<p>Formatting is affected by the flag settings in <em>io</em>.</p>
<p>The basic format is affected by the value of io.flags() &amp; ios_base::basefield. If equal to ios_base::oct, formats like the printf o specifier. Else if equal to ios_base::hex, formats like x or X with ios_base::uppercase unset or set respectively. Otherwise, formats like d, ld, lld for signed and u, lu, llu for unsigned values. Note that if both oct and hex are set, neither will take effect.</p>
<p>If ios_base::showpos is set, '+' is output before positive values. If ios_base::showbase is set, '0' precedes octal values (except 0) and '0[xX]' precedes hex values.</p>
<p>Thousands separators are inserted according to numpunct::grouping() and numpunct::thousands_sep(). The decimal point character used is numpunct::decimal_point().</p>
<p>If io.width() is non-zero, enough <em>fill</em> characters are inserted to make the result at least that wide. If (io.flags() &amp; ios_base::adjustfield) == ios_base::left, result is padded at the end. If ios_base::internal, then padding occurs immediately after either a '+' or '-' or after '0x' or '0X'. Otherwise, padding occurs at the beginning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">fill</td><td>Char_type to use for filling. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Numeric formatting.</p>
<p>Formats the floating point value <em>v</em> and inserts it into a stream. It does so by calling num_put::do_put().</p>
<p>Formatting is affected by the flag settings in <em>io</em>.</p>
<p>The basic format is affected by the value of io.flags() &amp; ios_base::floatfield. If equal to ios_base::fixed, formats like the printf f specifier. Else if equal to ios_base::scientific, formats like e or E with ios_base::uppercase unset or set respectively. Otherwise, formats like g or G depending on uppercase. Note that if both fixed and scientific are set, the effect will also be like g or G.</p>
<p>The output precision is given by io.precision(). This precision is capped at numeric_limits::digits10 + 2 (different for double and long double). The default precision is 6.</p>
<p>If ios_base::showpos is set, '+' is output before positive values. If ios_base::showpoint is set, a decimal point will always be output.</p>
<p>Thousands separators are inserted according to numpunct::grouping() and numpunct::thousands_sep(). The decimal point character used is numpunct::decimal_point().</p>
<p>If io.width() is non-zero, enough <em>fill</em> characters are inserted to make the result at least that wide. If (io.flags() &amp; ios_base::adjustfield) == ios_base::left, result is padded at the end. If ios_base::internal, then padding occurs immediately after either a '+' or '-' or after '0x' or '0X'. Otherwise, padding occurs at the beginning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">fill</td><td>Char_type to use for filling. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Numeric formatting.</p>
<p>Formats the pointer value <em>v</em> and inserts it into a stream. It does so by calling num_put::do_put().</p>
<p>This function formats <em>v</em> as an unsigned long with ios_base::hex and ios_base::showbase set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">fill</td><td>Char_type to use for filling. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Destructor.</p>
<p>Numeric formatting.</p>
<p>These functions do the work of formatting numeric values and inserting them into a stream. This function is a hook for derived classes to change the value returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale and flags. </td></tr>
    <tr><td class="paramname">fill</td><td>Char_type to use for filling. </td></tr>
    <tr><td class="paramname">v</td><td>Value to format and insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Convenience interface to ctype.is(ctype_base::space, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::print, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::cntrl, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::upper, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::lower, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::alpha, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::digit, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::punct, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::xdigit, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::alnum, __c).</p>
<p>Convenience interface to ctype.is(ctype_base::graph, __c).</p>
<p>Convenience interface to ctype.toupper(__c).</p>
<p>Convenience interface to ctype.tolower(__c).</p>
<p>Time format ordering data.</p>
<p>This class provides an enum representing different orderings of time: day, month, and year.</p>
<p>Numpunct facet id.</p>
<p>Internal constructor. Not for general use.</p>
<p>This is a constructor for use by the library itself to set up new locales.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloc</td><td>The C locale. </td></tr>
    <tr><td class="paramname">s</td><td>The name of a locale. </td></tr>
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Primary class template time_get.</p>
<p>This facet encapsulates the code to parse and return a date or time from a string. It is used by the istream numeric extraction operators.</p>
<p>The time_get template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the time_get facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Return preferred order of month, day, and year.</p>
<p>This function returns an enum from timebase::dateorder giving the preferred ordering if the format <em>x</em> given to time_put::put() only uses month, day, and year. If the format <em>x</em> for the associated locale uses other fields, this function returns timebase::dateorder::noorder.</p>
<p>NOTE: The library always returns noorder at the moment.</p>
<dl class="section return"><dt>Returns</dt><dd>A member of timebase::dateorder.</dd></dl>
<p>Parse input time string.</p>
<p>This function parses a time according to the format <em>X</em> and puts the results into a user-supplied struct tm. The result is returned by calling time_get::do_get_time().</p>
<p>If there is a valid time string according to format <em>X</em>, <em>tm</em> will be filled in accordingly and the returned iterator will point to the first character beyond the time string. If an error occurs before the end, err |= ios_base::failbit. If parsing reads all the characters, err |= ios_base::eofbit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond time string.</dd></dl>
<p>Parse input date string.</p>
<p>This function parses a date according to the format <em>x</em> and puts the results into a user-supplied struct tm. The result is returned by calling time_get::do_get_date().</p>
<p>If there is a valid date string according to format <em>x</em>, <em>tm</em> will be filled in accordingly and the returned iterator will point to the first character beyond the date string. If an error occurs before the end, err |= ios_base::failbit. If parsing reads all the characters, err |= ios_base::eofbit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond date string.</dd></dl>
<p>Parse input weekday string.</p>
<p>This function parses a weekday name and puts the results into a user-supplied struct tm. The result is returned by calling time_get::do_get_weekday().</p>
<p>Parsing starts by parsing an abbreviated weekday name. If a valid abbreviation is followed by a character that would lead to the full weekday name, parsing continues until the full name is found or an error occurs. Otherwise parsing finishes at the end of the abbreviated name.</p>
<p>If an error occurs before the end, err |= ios_base::failbit. If parsing reads all the characters, err |= ios_base::eofbit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond weekday name.</dd></dl>
<p>Parse input month string.</p>
<p>This function parses a month name and puts the results into a user-supplied struct tm. The result is returned by calling time_get::do_get_monthname().</p>
<p>Parsing starts by parsing an abbreviated month name. If a valid abbreviation is followed by a character that would lead to the full month name, parsing continues until the full name is found or an error occurs. Otherwise parsing finishes at the end of the abbreviated name.</p>
<p>If an error occurs before the end, err |= ios_base::failbit. If parsing reads all the characters, err |= ios_base::eofbit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond month name.</dd></dl>
<p>Parse input year string.</p>
<p>This function reads up to 4 characters to parse a year string and puts the results into a user-supplied struct tm. The result is returned by calling time_get::do_get_year().</p>
<p>4 consecutive digits are interpreted as a full year. If there are exactly 2 consecutive digits, the library interprets this as the number of years since 1900.</p>
<p>If an error occurs before the end, err |= ios_base::failbit. If parsing reads all the characters, err |= ios_base::eofbit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond year.</dd></dl>
<p>Destructor.</p>
<p>Return preferred order of month, day, and year.</p>
<p>This function returns an enum from timebase::dateorder giving the preferred ordering if the format <em>x</em> given to time_put::put() only uses month, day, and year. This function is a hook for derived classes to change the value returned.</p>
<dl class="section return"><dt>Returns</dt><dd>A member of timebase::dateorder.</dd></dl>
<p>Parse input time string.</p>
<p>This function parses a time according to the format <em>x</em> and puts the results into a user-supplied struct tm. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>get_time() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond time string.</dd></dl>
<p>Parse input date string.</p>
<p>This function parses a date according to the format <em>X</em> and puts the results into a user-supplied struct tm. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>get_date() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond date string.</dd></dl>
<p>Parse input weekday string.</p>
<p>This function parses a weekday name and puts the results into a user-supplied struct tm. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>get_weekday() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond weekday name.</dd></dl>
<p>Parse input month string.</p>
<p>This function parses a month name and puts the results into a user-supplied struct tm. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>get_monthname() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond month name.</dd></dl>
<p>Parse input year string.</p>
<p>This function reads up to 4 characters to parse a year string and puts the results into a user-supplied struct tm. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>get_year() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Start of string to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of string to parse. </td></tr>
    <tr><td class="paramname">io</td><td>Source of the locale. </td></tr>
    <tr><td class="paramname">err</td><td>Error flags to set. </td></tr>
    <tr><td class="paramname">tm</td><td>Pointer to struct tm to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to first char beyond year.</dd></dl>
<p>class time_get_byname [22.2.5.2].</p>
<p>Primary class template time_put.</p>
<p>This facet encapsulates the code to format and output dates and times according to formats used by <a class="el" href="../../de/df7/time_8h.html#aa7e6537d9f92525b9e2d06e0b767da0a">strftime()</a>.</p>
<p>The time_put template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the time_put facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Format and output a time or date.</p>
<p>This function formats the data in struct tm according to the provided format string. The format string is interpreted as by <a class="el" href="../../de/df7/time_8h.html#aa7e6537d9f92525b9e2d06e0b767da0a">strftime()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale. </td></tr>
    <tr><td class="paramname">fill</td><td>char_type to use for padding. </td></tr>
    <tr><td class="paramname">tm</td><td>Struct tm with date and time info to format. </td></tr>
    <tr><td class="paramname">beg</td><td>Start of format string. </td></tr>
    <tr><td class="paramname">end</td><td>End of format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Format and output a time or date.</p>
<p>This function formats the data in struct tm according to the provided format char and optional modifier. The format and modifier are interpreted as by <a class="el" href="../../de/df7/time_8h.html#aa7e6537d9f92525b9e2d06e0b767da0a">strftime()</a>. It does so by returning time_put::do_put().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale. </td></tr>
    <tr><td class="paramname">fill</td><td>char_type to use for padding. </td></tr>
    <tr><td class="paramname">tm</td><td>Struct tm with date and time info to format. </td></tr>
    <tr><td class="paramname">format</td><td>Format char. </td></tr>
    <tr><td class="paramname">mod</td><td>Optional modifier char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Destructor.</p>
<p>Format and output a time or date.</p>
<p>This function formats the data in struct tm according to the provided format char and optional modifier. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>put() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">io</td><td>Source of locale. </td></tr>
    <tr><td class="paramname">fill</td><td>char_type to use for padding. </td></tr>
    <tr><td class="paramname">tm</td><td>Struct tm with date and time info to format. </td></tr>
    <tr><td class="paramname">format</td><td>Format char. </td></tr>
    <tr><td class="paramname">mod</td><td>Optional modifier char. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>class time_put_byname [22.2.5.4].</p>
<p>Money format ordering data.</p>
<p>This class contains an ordered array of 4 fields to represent the pattern for formatting a money amount. Each field may contain one entry from the part enum. symbol, sign, and value must be present and the remaining field must contain either none or space. </p><dl class="section see"><dt>See also</dt><dd>moneypunct::pos_format() <a class="el" href="../../d1/d9a/iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a> moneypunct::neg_format() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details of how these <a class="el" href="../../d7/d90/g__spawn_8c.html#a968ec84358fe7df6b8c78c179c6f9dbd">fields</a> are interpreted.</dd></dl>
<p>Primary class template moneypunct.</p>
<p>This facet encapsulates the punctuation, grouping and other formatting features of money amount string representations.</p>
<p>Public typedefs</p>
<p>This value is provided by the standard, but no reason for its existence.</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructor performs initialization.</p>
<p>This is an internal constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Cache for optimization. </td></tr>
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Internal constructor. Not for general use.</p>
<p>This is a constructor for use by the library itself to set up new locales.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloc</td><td>The C locale. </td></tr>
    <tr><td class="paramname">s</td><td>The name of a locale. </td></tr>
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Return decimal point character.</p>
<p>This function returns a char_type to use as a decimal point. It does so by returning returning moneypunct&lt;char_type&gt;::do_decimal_point().</p>
<dl class="section return"><dt>Returns</dt><dd><em>char_type</em> representing a decimal point.</dd></dl>
<p>Return thousands separator character.</p>
<p>This function returns a char_type to use as a thousands separator. It does so by returning returning moneypunct&lt;char_type&gt;::do_thousands_sep().</p>
<dl class="section return"><dt>Returns</dt><dd>char_type representing a thousands separator.</dd></dl>
<p>Return grouping specification.</p>
<p>This function returns a string representing groupings for the integer part of an amount. Groupings indicate where thousands separators should be inserted.</p>
<p>Each char in the return string is interpret as an integer rather than a character. These numbers represent the number of digits in a group. The first char in the string represents the number of digits in the least significant group. If a char is negative, it indicates an unlimited number of digits for the group. If more chars from the string are required to group a number, the last char is used repeatedly.</p>
<p>For example, if the grouping() returns <code>\003\002</code> and is applied to the number 123456789, this corresponds to 12,34,56,789. Note that if the string was <code>32</code>, this would put more than 50 digits into the least significant group if the character set is ASCII.</p>
<p>The string is returned by calling moneypunct&lt;char_type&gt;::do_grouping().</p>
<dl class="section return"><dt>Returns</dt><dd>string representing grouping specification.</dd></dl>
<p>Return currency symbol string.</p>
<p>This function returns a string_type to use as a currency symbol. It does so by returning returning moneypunct&lt;char_type&gt;::do_curr_symbol().</p>
<dl class="section return"><dt>Returns</dt><dd><em>string_type</em> representing a currency symbol.</dd></dl>
<p>Return positive sign string.</p>
<p>This function returns a string_type to use as a sign for positive amounts. It does so by returning returning moneypunct&lt;char_type&gt;::do_positive_sign().</p>
<p>If the return value contains more than one character, the first character appears in the position indicated by pos_format() and the remainder appear at the end of the formatted string.</p>
<dl class="section return"><dt>Returns</dt><dd><em>string_type</em> representing a positive sign.</dd></dl>
<p>Return negative sign string.</p>
<p>This function returns a string_type to use as a sign for negative amounts. It does so by returning returning moneypunct&lt;char_type&gt;::do_negative_sign().</p>
<p>If the return value contains more than one character, the first character appears in the position indicated by neg_format() and the remainder appear at the end of the formatted string.</p>
<dl class="section return"><dt>Returns</dt><dd><em>string_type</em> representing a negative sign.</dd></dl>
<p>Return number of digits in fraction.</p>
<p>This function returns the exact number of digits that make up the fractional part of a money amount. It does so by returning returning moneypunct&lt;char_type&gt;::do_frac_digits().</p>
<p>The fractional part of a money amount is optional. But if it is present, there must be frac_digits() digits.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of digits in amount fraction.</dd></dl>
<p>Return pattern for money values.</p>
<p>This function returns a pattern describing the formatting of a positive or negative valued money amount. It does so by returning returning moneypunct&lt;char_type&gt;::do_pos_format() or moneypunct&lt;char_type&gt;::do_neg_format().</p>
<p>The pattern has 4 fields describing the ordering of symbol, sign, value, and none or space. There must be one of each in the pattern. The none and space enums may not appear in the first field and space may not appear in the final field.</p>
<p>The parts of a money string must appear in the order indicated by the fields of the pattern. The symbol field indicates that the value of curr_symbol() may be present. The sign field indicates that the value of positive_sign() or negative_sign() must be present. The value field indicates that the absolute value of the money amount is present. none indicates 0 or more whitespace characters, except at the end, where it permits no whitespace. space indicates that 1 or more whitespace characters must be present.</p>
<p>For example, for the US locale and pos_format() pattern {symbol,sign,value,none}, curr_symbol() == '$' positive_sign() == '+', and value 10.01, and options set to force the symbol, the corresponding string is <code>$+10.01</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pattern for money values.</dd></dl>
<p>Destructor.</p>
<p>Return decimal point character.</p>
<p>Returns a char_type to use as a decimal point. This function is a hook for derived classes to change the value returned.</p>
<dl class="section return"><dt>Returns</dt><dd><em>char_type</em> representing a decimal point.</dd></dl>
<p>Return thousands separator character.</p>
<p>Returns a char_type to use as a thousands separator. This function is a hook for derived classes to change the value returned.</p>
<dl class="section return"><dt>Returns</dt><dd><em>char_type</em> representing a thousands separator.</dd></dl>
<p>Return grouping specification.</p>
<p>Returns a string representing groupings for the integer part of a number. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>grouping() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>String representing grouping specification.</dd></dl>
<p>Return currency symbol string.</p>
<p>This function returns a string_type to use as a currency symbol. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>curr_symbol() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><em>string_type</em> representing a currency symbol.</dd></dl>
<p>Return positive sign string.</p>
<p>This function returns a string_type to use as a sign for positive amounts. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>positive_sign() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><em>string_type</em> representing a positive sign.</dd></dl>
<p>Return negative sign string.</p>
<p>This function returns a string_type to use as a sign for negative amounts. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>negative_sign() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><em>string_type</em> representing a negative sign.</dd></dl>
<p>Return number of digits in fraction.</p>
<p>This function returns the exact number of digits that make up the fractional part of a money amount. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>frac_digits() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of digits in amount fraction.</dd></dl>
<p>Return pattern for money values.</p>
<p>This function returns a pattern describing the formatting of a positive valued money amount. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>pos_format() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pattern for money values.</dd></dl>
<p>Return pattern for money values.</p>
<p>This function returns a pattern describing the formatting of a negative valued money amount. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>neg_format() <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pattern for money values.</dd></dl>
<p>class moneypunct_byname [22.2.6.4].</p>
<p>Primary class template money_get.</p>
<p>This facet encapsulates the code to parse and return a monetary amount from a string.</p>
<p>The money_get template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the money_get facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Read and parse a monetary value.</p>
<p>This function reads characters from <em>s</em>, interprets them as a monetary value according to moneypunct and ctype facets retrieved from io.getloc(), and returns the result in <em>units</em> as an integral value moneypunct::frac_digits() * the actual amount. For example, the string $10.01 in a US locale would store 1001 in <em>units</em>.</p>
<p>Any characters not part of a valid money amount are not consumed.</p>
<p>If a money value cannot be parsed from the input stream, sets err=(err|io.failbit). If the stream is consumed before finishing parsing, sets err=(err|io.failbit|io.eofbit). <em>units</em> is unchanged if parsing fails.</p>
<p>This function works by returning the result of do_get().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Start of characters to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of characters to parse. </td></tr>
    <tr><td class="paramname">intl</td><td>Parameter to use_facet&lt;moneypunct&lt;CharT,intl&gt; &gt;. </td></tr>
    <tr><td class="paramname">io</td><td>Source of facets and io state. </td></tr>
    <tr><td class="paramname">err</td><td>Error field to set if parsing fails. </td></tr>
    <tr><td class="paramname">units</td><td>Place to store result of parsing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing first character beyond valid money amount.</dd></dl>
<p>Read and parse a monetary value.</p>
<p>This function reads characters from <em>s</em>, interprets them as a monetary value according to moneypunct and ctype facets retrieved from io.getloc(), and returns the result in <em>digits</em>. For example, the string $10.01 in a US locale would store <code>1001</code> in <em>digits</em>.</p>
<p>Any characters not part of a valid money amount are not consumed.</p>
<p>If a money value cannot be parsed from the input stream, sets err=(err|io.failbit). If the stream is consumed before finishing parsing, sets err=(err|io.failbit|io.eofbit).</p>
<p>This function works by returning the result of do_get().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Start of characters to parse. </td></tr>
    <tr><td class="paramname">end</td><td>End of characters to parse. </td></tr>
    <tr><td class="paramname">intl</td><td>Parameter to use_facet&lt;moneypunct&lt;CharT,intl&gt; &gt;. </td></tr>
    <tr><td class="paramname">io</td><td>Source of facets and io state. </td></tr>
    <tr><td class="paramname">err</td><td>Error field to set if parsing fails. </td></tr>
    <tr><td class="paramname">digits</td><td>Place to store result of parsing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing first character beyond valid money amount.</dd></dl>
<p>Destructor.</p>
<p>Read and parse a monetary value.</p>
<p>This function reads and parses characters representing a monetary value. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d7f/gram_8c.html#a3ce4e86bf8e816c7d7bd993acfa107fe">get()</a> <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<p>Read and parse a monetary value.</p>
<p>This function reads and parses characters representing a monetary value. This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d7f/gram_8c.html#a3ce4e86bf8e816c7d7bd993acfa107fe">get()</a> <a class="el" href="../../df/d95/lalr1_8cc.html#a8b9eb702eb3f9bcba3923532d1e801db">for</a> details.</dd></dl>
<p>Primary class template money_put.</p>
<p>This facet encapsulates the code to format and output a monetary amount.</p>
<p>The money_put template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the money_put facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Format and output a monetary value.</p>
<p>This function formats <em>units</em> as a monetary value according to moneypunct and ctype facets retrieved from io.getloc(), and writes the resulting characters to <em>s</em>. For example, the value 1001 in a US locale would write <code>$10.01</code> to <em>s</em>.</p>
<p>This function works by returning the result of do_put().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">intl</td><td>Parameter to use_facet&lt;moneypunct&lt;CharT,intl&gt; &gt;. </td></tr>
    <tr><td class="paramname">io</td><td>Source of facets and io state. </td></tr>
    <tr><td class="paramname">fill</td><td>char_type to use for padding. </td></tr>
    <tr><td class="paramname">units</td><td>Place to store result of parsing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Format and output a monetary value.</p>
<p>This function formats <em>digits</em> as a monetary value according to moneypunct and ctype facets retrieved from io.getloc(), and writes the resulting characters to <em>s</em>. For example, the string <code>1001</code> in a US locale would write <code>$10.01</code> to <em>s</em>.</p>
<p>This function works by returning the result of do_put().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">intl</td><td>Parameter to use_facet&lt;moneypunct&lt;CharT,intl&gt; &gt;. </td></tr>
    <tr><td class="paramname">io</td><td>Source of facets and io state. </td></tr>
    <tr><td class="paramname">fill</td><td>char_type to use for padding. </td></tr>
    <tr><td class="paramname">units</td><td>Place to store result of parsing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Destructor.</p>
<p>Format and output a monetary value.</p>
<p>This function formats <em>units</em> as a monetary value according to moneypunct and ctype facets retrieved from io.getloc(), and writes the resulting characters to <em>s</em>. For example, the value 1001 in a US locale would write <code>$10.01</code> to <em>s</em>.</p>
<p>This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>put().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">intl</td><td>Parameter to use_facet&lt;moneypunct&lt;CharT,intl&gt; &gt;. </td></tr>
    <tr><td class="paramname">io</td><td>Source of facets and io state. </td></tr>
    <tr><td class="paramname">fill</td><td>char_type to use for padding. </td></tr>
    <tr><td class="paramname">units</td><td>Place to store result of parsing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Format and output a monetary value.</p>
<p>This function formats <em>digits</em> as a monetary value according to moneypunct and ctype facets retrieved from io.getloc(), and writes the resulting characters to <em>s</em>. For example, the string <code>1001</code> in a US locale would write <code>$10.01</code> to <em>s</em>.</p>
<p>This function is a hook for derived classes to change the value returned. </p><dl class="section see"><dt>See also</dt><dd>put().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream to write to. </td></tr>
    <tr><td class="paramname">intl</td><td>Parameter to use_facet&lt;moneypunct&lt;CharT,intl&gt; &gt;. </td></tr>
    <tr><td class="paramname">io</td><td>Source of facets and io state. </td></tr>
    <tr><td class="paramname">fill</td><td>char_type to use for padding. </td></tr>
    <tr><td class="paramname">units</td><td>Place to store result of parsing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator after writing.</dd></dl>
<p>Messages facet base class providing catalog typedef.</p>
<p>Primary class template messages.</p>
<p>This facet encapsulates the code to retrieve messages from message catalogs. The only thing defined by the standard for this facet is the interface. All underlying functionality is implementation-defined.</p>
<p>This library currently implements 3 versions of the message facet. The first version (gnu) is a wrapper around gettext, provided by libintl. The second version (ieee) is a wrapper around catgets. The final version (default) does no actual translation. These implementations are only provided for char and wchar_t instantiations.</p>
<p>The messages template uses protected virtual functions to provide the actual results. The public accessors forward the call to the virtual functions. These virtual functions are hooks for developers to implement the behavior they require from the messages facet.</p>
<p>Public typedefs</p>
<p>Numpunct facet id.</p>
<p>Constructor performs initialization.</p>
<p>This is the constructor provided by the standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">refs</td><td>Passed to the base facet class.</td></tr>
  </table>
  </dd>
</dl>
<p>Internal constructor. Not for general use.</p>
<p>This is a constructor for use by the library itself to set up new locales.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloc</td><td>The C locale. </td></tr>
    <tr><td class="paramname">s</td><td>The name of a locale. </td></tr>
    <tr><td class="paramname">refs</td><td>Refcount to pass to the base class.</td></tr>
  </table>
  </dd>
</dl>
<p>Destructor.</p>
<p>Specializations for required instantiations.</p>
<p>class messages_byname [22.2.7.2].</p>

<p class="definition">Definition at line <a class="el" href="../../d7/d91/codecvt_8h_source.html#l00042">42</a> of file <a class="el" href="../../d7/d91/codecvt_8h_source.html">codecvt.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;{</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;_GLIBCXX_BEGIN_NAMESPACE_VERSION</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  <span class="keyword">class </span>codecvt_base</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  {</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;  <span class="keyword">public</span>:</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keyword">enum</span> result</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      ok,</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;      partial,</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;      <a class="code" href="../../de/de3/cpp_8c.html#ac98c2f304c5f323b7d8a9dd5522027fa">error</a>,</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;      noconv</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    };</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  };</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InternT, <span class="keyword">typename</span> _ExternT, <span class="keyword">typename</span> _StateT&gt;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keyword">class </span>__codecvt_abstract_base</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    : <span class="keyword">public</span> locale::facet, <span class="keyword">public</span> codecvt_base</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;      <span class="comment">// Types:</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      <span class="keyword">typedef</span> codecvt_base::result  result;</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;      <span class="keyword">typedef</span> _InternT          intern_type;</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;      <span class="keyword">typedef</span> _ExternT          extern_type;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;      <span class="keyword">typedef</span> _StateT           <a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>;</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;      <span class="comment">// 22.2.1.5.1 codecvt members</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"></span>      result</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;      <a class="code" href="../../da/d03/vm__x86__64__assembler_8c.html#a392d7ef877b6258e64850ce3a2647dae">out</a>(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> intern_type* __from,</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      <span class="keyword">const</span> intern_type* __from_end, <span class="keyword">const</span> intern_type*&amp; __from_next,</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      extern_type* __to, extern_type* __to_end,</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;      extern_type*&amp; __to_next)<span class="keyword"> const</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="keywordflow">return</span> this-&gt;do_out(__state, __from, __from_end, __from_next,</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                __to, __to_end, __to_next);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      }</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160; </div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      result</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      unshift(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, extern_type* __to, extern_type* __to_end,</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;          extern_type*&amp; __to_next)<span class="keyword"> const</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;do_unshift(__state, __to,__to_end,__to_next); }</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160; </div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;      result</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      <a class="code" href="../../d6/ddb/vm__powerpc_8c.html#a73b4db2550aa2a30b76ff1e7f43cc906">in</a>(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> extern_type* __from,</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;     <span class="keyword">const</span> extern_type* __from_end, <span class="keyword">const</span> extern_type*&amp; __from_next,</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;     intern_type* __to, intern_type* __to_end,</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;     intern_type*&amp; __to_next)<span class="keyword"> const</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="keyword">      </span>{</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordflow">return</span> this-&gt;do_in(__state, __from, __from_end, __from_next,</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;               __to, __to_end, __to_next);</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      }</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160; </div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      <span class="keywordtype">int</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      encoding() <span class="keyword">const</span> throw()</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      { <span class="keywordflow">return</span> this-&gt;do_encoding(); }</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160; </div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      <span class="keywordtype">bool</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      always_noconv() <span class="keyword">const</span> throw()</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      { <span class="keywordflow">return</span> this-&gt;do_always_noconv(); }</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160; </div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      <span class="keywordtype">int</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a78c5c8710130a1a634d6a81d52be8db8">length</a>(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> extern_type* __from,</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;         <span class="keyword">const</span> extern_type* __end, <span class="keywordtype">size_t</span> __max)<span class="keyword"> const</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;do_length(__state, __from, __end, __max); }</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160; </div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      <span class="keywordtype">int</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      max_length() <span class="keyword">const</span> throw()</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      { <span class="keywordflow">return</span> this-&gt;do_max_length(); }</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160; </div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      __codecvt_abstract_base(<span class="keywordtype">size_t</span> __refs = 0) : locale::facet(__refs) { }</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160; </div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      <span class="keyword">virtual</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      ~__codecvt_abstract_base() { }</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160; </div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      do_out(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> intern_type* __from,</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;         <span class="keyword">const</span> intern_type* __from_end, <span class="keyword">const</span> intern_type*&amp; __from_next,</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;         extern_type* __to, extern_type* __to_end,</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;         extern_type*&amp; __to_next) <span class="keyword">const</span> = 0;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160; </div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      do_unshift(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, extern_type* __to,</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;         extern_type* __to_end, extern_type*&amp; __to_next) <span class="keyword">const</span> = 0;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160; </div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      do_in(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> extern_type* __from,</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keyword">const</span> extern_type* __from_end, <span class="keyword">const</span> extern_type*&amp; __from_next,</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        intern_type* __to, intern_type* __to_end,</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        intern_type*&amp; __to_next) <span class="keyword">const</span> = 0;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160; </div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="keyword">virtual</span> <span class="keywordtype">int</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      do_encoding() <span class="keyword">const</span> throw() = 0;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160; </div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      virtual <span class="keywordtype">bool</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      do_always_noconv() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw() = 0;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160; </div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      virtual <span class="keywordtype">int</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      do_length(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp;, <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __from,</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __end, <span class="keywordtype">size_t</span> __max) <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> = 0;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160; </div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      virtual <span class="keywordtype">int</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      do_max_length() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw() = 0;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    };</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160; </div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160; </div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; </div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;   template&lt;<a class="code" href="../../d2/dc5/c_8h.html#a2de029f4c2cf20c4abc26c006c28838c">typename</a> _InternT, <a class="code" href="../../d2/dc5/c_8h.html#a2de029f4c2cf20c4abc26c006c28838c">typename</a> _ExternT, <a class="code" href="../../d2/dc5/c_8h.html#a2de029f4c2cf20c4abc26c006c28838c">typename</a> _StateT&gt;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    class codecvt</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    : public __codecvt_abstract_base&lt;_InternT, _ExternT, _StateT&gt;</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    {</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <span class="comment">// Types:</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;      <span class="keyword">typedef</span> codecvt_base::result  result;</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;      <span class="keyword">typedef</span> _InternT          intern_type;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      <span class="keyword">typedef</span> _ExternT          extern_type;</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;      <span class="keyword">typedef</span> _StateT           <a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160; </div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      __c_locale            _M_c_locale_codecvt;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160; </div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      <span class="keyword">static</span> <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a58c2a664503e14ffb8f21012aabff3e9">locale::id</a>         <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160; </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      codecvt(<span class="keywordtype">size_t</span> __refs = 0)</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      : __codecvt_abstract_base&lt;_InternT, _ExternT, _StateT&gt; (__refs) { }</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160; </div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      codecvt(__c_locale __cloc, <span class="keywordtype">size_t</span> __refs = 0);</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160; </div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;      <span class="keyword">virtual</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      ~codecvt() { }</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160; </div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;      do_out(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> intern_type* __from,</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;         <span class="keyword">const</span> intern_type* __from_end, <span class="keyword">const</span> intern_type*&amp; __from_next,</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;         extern_type* __to, extern_type* __to_end,</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;         extern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160; </div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;      do_unshift(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, extern_type* __to,</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;         extern_type* __to_end, extern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160; </div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;      do_in(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> extern_type* __from,</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        <span class="keyword">const</span> extern_type* __from_end, <span class="keyword">const</span> extern_type*&amp; __from_next,</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        intern_type* __to, intern_type* __to_end,</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        intern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160; </div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;      <span class="keyword">virtual</span> <span class="keywordtype">int</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;      do_encoding() <span class="keyword">const</span> throw();</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160; </div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;      virtual <span class="keywordtype">bool</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;      do_always_noconv() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw();</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160; </div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;      virtual <span class="keywordtype">int</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;      do_length(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp;, <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __from,</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __end, <span class="keywordtype">size_t</span> __max) <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a>;</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160; </div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;      virtual <span class="keywordtype">int</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;      do_max_length() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw();</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    };</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160; </div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  template&lt;<a class="code" href="../../d2/dc5/c_8h.html#a2de029f4c2cf20c4abc26c006c28838c">typename</a> _InternT, <a class="code" href="../../d2/dc5/c_8h.html#a2de029f4c2cf20c4abc26c006c28838c">typename</a> _ExternT, <a class="code" href="../../d2/dc5/c_8h.html#a2de029f4c2cf20c4abc26c006c28838c">typename</a> _StateT&gt;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    locale::<span class="keywordtype">id</span> codecvt&lt;_InternT, _ExternT, _StateT&gt;::<span class="keywordtype">id</span>;</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160; </div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  template&lt;&gt;</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    class codecvt&lt;<span class="keywordtype">char</span>, <span class="keywordtype">char</span>, <a class="code" href="../../d9/dae/wchar_8h.html#a1de24253f2f92571d487ee757ab055e2">mbstate_t</a>&gt;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    : public __codecvt_abstract_base&lt;<span class="keywordtype">char</span>, <span class="keywordtype">char</span>, <a class="code" href="../../d9/dae/wchar_8h.html#a1de24253f2f92571d487ee757ab055e2">mbstate_t</a>&gt;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    {</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;      <span class="comment">// Types:</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      <span class="keyword">typedef</span> <span class="keywordtype">char</span>          intern_type;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;      <span class="keyword">typedef</span> <span class="keywordtype">char</span>          extern_type;</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      <span class="keyword">typedef</span> <a class="code" href="../../d9/dae/wchar_8h.html#a1de24253f2f92571d487ee757ab055e2">mbstate_t</a>         <a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160; </div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;      __c_locale            _M_c_locale_codecvt;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160; </div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;      <span class="keyword">static</span> <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a58c2a664503e14ffb8f21012aabff3e9">locale::id</a> <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160; </div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;      codecvt(<span class="keywordtype">size_t</span> __refs = 0);</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160; </div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;      codecvt(__c_locale __cloc, <span class="keywordtype">size_t</span> __refs = 0);</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160; </div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;      <span class="keyword">virtual</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      ~codecvt();</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160; </div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;      do_out(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> intern_type* __from,</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;         <span class="keyword">const</span> intern_type* __from_end, <span class="keyword">const</span> intern_type*&amp; __from_next,</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;         extern_type* __to, extern_type* __to_end,</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;         extern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160; </div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      do_unshift(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, extern_type* __to,</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;         extern_type* __to_end, extern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160; </div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;      do_in(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> extern_type* __from,</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        <span class="keyword">const</span> extern_type* __from_end, <span class="keyword">const</span> extern_type*&amp; __from_next,</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        intern_type* __to, intern_type* __to_end,</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        intern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160; </div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;      <span class="keyword">virtual</span> <span class="keywordtype">int</span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      do_encoding() <span class="keyword">const</span> throw();</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160; </div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      virtual <span class="keywordtype">bool</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;      do_always_noconv() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw();</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160; </div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;      virtual <span class="keywordtype">int</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;      do_length(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp;, <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __from,</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __end, <span class="keywordtype">size_t</span> __max) <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a>;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160; </div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      virtual <span class="keywordtype">int</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;      do_max_length() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw();</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  };</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160; </div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="preprocessor">#ifdef _GLIBCXX_USE_WCHAR_T</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;  <span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="keyword">class </span>codecvt&lt;<a class="code" href="../../d9/dfa/winnt_8h.html#a9026fbe0621f8d881c7bc984a03c8b06">wchar_t</a>, char, <a class="code" href="../../d9/dae/wchar_8h.html#a1de24253f2f92571d487ee757ab055e2">mbstate_t</a>&gt;</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    : <span class="keyword">public</span> __codecvt_abstract_base&lt;wchar_t, char, mbstate_t&gt;</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;      <span class="comment">// Types:</span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;      <span class="keyword">typedef</span> <span class="keywordtype">wchar_t</span>           intern_type;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      <span class="keyword">typedef</span> <span class="keywordtype">char</span>          extern_type;</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;      <span class="keyword">typedef</span> <a class="code" href="../../d9/dae/wchar_8h.html#a1de24253f2f92571d487ee757ab055e2">mbstate_t</a>         <a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160; </div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;      __c_locale            _M_c_locale_codecvt;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160; </div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;      <span class="keyword">static</span> <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a58c2a664503e14ffb8f21012aabff3e9">locale::id</a>         <a class="code" href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a>;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160; </div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      codecvt(<span class="keywordtype">size_t</span> __refs = 0);</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; </div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;      codecvt(__c_locale __cloc, <span class="keywordtype">size_t</span> __refs = 0);</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160; </div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;      <span class="keyword">virtual</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;      ~codecvt();</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160; </div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;      do_out(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state, <span class="keyword">const</span> intern_type* __from,</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;         <span class="keyword">const</span> intern_type* __from_end, <span class="keyword">const</span> intern_type*&amp; __from_next,</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;         extern_type* __to, extern_type* __to_end,</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;         extern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160; </div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;      do_unshift(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state,</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;         extern_type* __to, extern_type* __to_end,</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;         extern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160; </div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;      <span class="keyword">virtual</span> result</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;      do_in(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp; __state,</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;         <span class="keyword">const</span> extern_type* __from, <span class="keyword">const</span> extern_type* __from_end,</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;         <span class="keyword">const</span> extern_type*&amp; __from_next,</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;         intern_type* __to, intern_type* __to_end,</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;         intern_type*&amp; __to_next) <span class="keyword">const</span>;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160; </div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;      <span class="keyword">virtual</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;      <span class="keywordtype">int</span> do_encoding() <span class="keyword">const</span> throw();</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160; </div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;      virtual</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;      <span class="keywordtype">bool</span> do_always_noconv() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw();</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160; </div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      virtual</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      <span class="keywordtype">int</span> do_length(<a class="code" href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a>&amp;, <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __from,</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> extern_type* __end, <span class="keywordtype">size_t</span> __max) <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a>;</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160; </div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      virtual <span class="keywordtype">int</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      do_max_length() <a class="code" href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> throw();</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    };</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="preprocessor">#endif //_GLIBCXX_USE_WCHAR_T</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160; </div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InternT, <span class="keyword">typename</span> _ExternT, <span class="keyword">typename</span> _StateT&gt;</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="keyword">class </span>codecvt_byname : <span class="keyword">public</span> codecvt&lt;_InternT, _ExternT, _StateT&gt;</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    {</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="keyword">public</span>:</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      <span class="keyword">explicit</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;      codecvt_byname(<span class="keyword">const</span> <span class="keywordtype">char</span>* __s, <span class="keywordtype">size_t</span> __refs = 0)</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      : codecvt&lt;_InternT, _ExternT, _StateT&gt;(__refs)</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;      {</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keywordflow">if</span> (__builtin_strcmp(__s, <span class="stringliteral">&quot;C&quot;</span>) != 0</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        &amp;&amp; __builtin_strcmp(__s, <span class="stringliteral">&quot;POSIX&quot;</span>) != 0)</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      {</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        this-&gt;_S_destroy_c_locale(this-&gt;_M_c_locale_codecvt);</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        this-&gt;_S_create_c_locale(this-&gt;_M_c_locale_codecvt, __s);</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;      }</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;      }</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160; </div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keyword">protected</span>:</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;      <span class="keyword">virtual</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;      ~codecvt_byname() { }</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    };</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160; </div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  <span class="comment">// Inhibit implicit instantiations for required instantiations,</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  <span class="comment">// which are defined via explicit instantiations elsewhere.</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;<span class="preprocessor">#if _GLIBCXX_EXTERN_TEMPLATE</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>codecvt_byname&lt;char, char, mbstate_t&gt;;</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160; </div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  <span class="keyword">extern</span> <span class="keyword">template</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keyword">const</span> codecvt&lt;char, char, mbstate_t&gt;&amp;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    use_facet&lt;codecvt&lt;char, char, mbstate_t&gt; &gt;(<span class="keyword">const</span> locale&amp;);</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160; </div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;  <span class="keyword">extern</span> <span class="keyword">template</span></div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keywordtype">bool</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    has_facet&lt;codecvt&lt;char, char, mbstate_t&gt; &gt;(<span class="keyword">const</span> locale&amp;);</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160; </div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;<span class="preprocessor">#ifdef _GLIBCXX_USE_WCHAR_T</span></div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>codecvt_byname&lt;wchar_t, char, mbstate_t&gt;;</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160; </div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  <span class="keyword">extern</span> <span class="keyword">template</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keyword">const</span> codecvt&lt;wchar_t, char, mbstate_t&gt;&amp;</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    use_facet&lt;codecvt&lt;wchar_t, char, mbstate_t&gt; &gt;(<span class="keyword">const</span> locale&amp;);</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160; </div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  <span class="keyword">extern</span> <span class="keyword">template</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keywordtype">bool</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    has_facet&lt;codecvt&lt;wchar_t, char, mbstate_t&gt; &gt;(<span class="keyword">const</span> locale&amp;);</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160; </div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;_GLIBCXX_END_NAMESPACE_VERSION</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;} <span class="comment">// namespace std</span></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../de/de3/cpp_8c_source.html#l00273">error()</a>, <a class="el" href="../../d6/ddb/vm__powerpc_8c_source.html#l00538">in</a>, and <a class="el" href="../../da/d03/vm__x86__64__assembler_8c_source.html#l00045">out</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="awinnt_8h_html_a9026fbe0621f8d881c7bc984a03c8b06"><div class="ttname"><a href="../../d9/dfa/winnt_8h.html#a9026fbe0621f8d881c7bc984a03c8b06">wchar_t</a></div><div class="ttdeci">unsigned short wchar_t</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/dfa/winnt_8h_source.html#l00100">winnt.h:100</a></div></div>
<div class="ttc" id="aEngine_2SDL12_2include_2SDL__opengl_8h_html_a58c2a664503e14ffb8f21012aabff3e9"><div class="ttname"><a href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a58c2a664503e14ffb8f21012aabff3e9">id</a></div><div class="ttdeci">GLuint id</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h_source.html#l03438">SDL_opengl.h:3438</a></div></div>
<div class="ttc" id="ac_8h_html_a2de029f4c2cf20c4abc26c006c28838c"><div class="ttname"><a href="../../d2/dc5/c_8h.html#a2de029f4c2cf20c4abc26c006c28838c">typename</a></div><div class="ttdeci">Type typename(void)</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d28/decl_8c_source.html#l01152">decl.c:1152</a></div></div>
<div class="ttc" id="avm__powerpc_8c_html_a73b4db2550aa2a30b76ff1e7f43cc906"><div class="ttname"><a href="../../d6/ddb/vm__powerpc_8c.html#a73b4db2550aa2a30b76ff1e7f43cc906">in</a></div><div class="ttdeci">#define in(inst, args...)</div><div class="ttdef"><b>Definition:</b> <a href="../../d6/ddb/vm__powerpc_8c_source.html#l00538">vm_powerpc.c:538</a></div></div>
<div class="ttc" id="aEngine_2SDL12_2include_2SDL__opengl_8h_html_adfdba28282fbf886223676912be34ab4"><div class="ttname"><a href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#adfdba28282fbf886223676912be34ab4">v</a></div><div class="ttdeci">const GLdouble * v</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h_source.html#l03271">SDL_opengl.h:3271</a></div></div>
<div class="ttc" id="avm__x86__64__assembler_8c_html_a392d7ef877b6258e64850ce3a2647dae"><div class="ttname"><a href="../../da/d03/vm__x86__64__assembler_8c.html#a392d7ef877b6258e64850ce3a2647dae">out</a></div><div class="ttdeci">static char * out</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d03/vm__x86__64__assembler_8c_source.html#l00045">vm_x86_64_assembler.c:45</a></div></div>
<div class="ttc" id="aEngine_2zlib_2zconf_8h_html_a2c212835823e3c54a8ab6d95c652660e"><div class="ttname"><a href="../../d7/dff/Engine_2zlib_2zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a></div><div class="ttdeci">#define const</div><div class="ttdef"><b>Definition:</b> <a href="../../d7/dff/Engine_2zlib_2zconf_8h_source.html#l00124">zconf.h:124</a></div></div>
<div class="ttc" id="awchar_8h_html_a1de24253f2f92571d487ee757ab055e2"><div class="ttname"><a href="../../d9/dae/wchar_8h.html#a1de24253f2f92571d487ee757ab055e2">mbstate_t</a></div><div class="ttdeci">int mbstate_t</div><div class="ttdef"><b>Definition:</b> <a href="../../d9/dae/wchar_8h_source.html#l00295">wchar.h:295</a></div></div>
<div class="ttc" id="alalr1_8cc_html_a4861a0fbaead9c843f2bc3d0134f8222"><div class="ttname"><a href="../../df/d95/lalr1_8cc.html#a4861a0fbaead9c843f2bc3d0134f8222">state_type</a></div><div class="ttdeci">int state_type</div><div class="ttdoc">State numbers.</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d95/lalr1_8cc_source.html#l00177">lalr1.cc:177</a></div></div>
<div class="ttc" id="acpp_8c_html_ac98c2f304c5f323b7d8a9dd5522027fa"><div class="ttname"><a href="../../de/de3/cpp_8c.html#ac98c2f304c5f323b7d8a9dd5522027fa">error</a></div><div class="ttdeci">void error(enum errtype type, char *string,...)</div><div class="ttdef"><b>Definition:</b> <a href="../../de/de3/cpp_8c_source.html#l00273">cpp.c:273</a></div></div>
<div class="ttc" id="aEngine_2SDL12_2include_2SDL__opengl_8h_html_a78c5c8710130a1a634d6a81d52be8db8"><div class="ttname"><a href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h.html#a78c5c8710130a1a634d6a81d52be8db8">length</a></div><div class="ttdeci">GLuint GLsizei GLsizei * length</div><div class="ttdef"><b>Definition:</b> <a href="../../d3/db7/Engine_2SDL12_2include_2SDL__opengl_8h_source.html#l03568">SDL_opengl.h:3568</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Feb 27 2022 19:19:55 for ZEQ2-Lite by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
