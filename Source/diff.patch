Index: Game/CGame/cg_auras.c
===================================================================
--- Game/CGame/cg_auras.c	(revision 1956)
+++ Game/CGame/cg_auras.c	(working copy)
@@ -720,18 +720,13 @@
 CG_Aura_AddDLight
 ===================*/
 static void CG_Aura_AddDLight( centity_t *player, auraState_t *state, auraConfig_t *config){
-	vec3_t	lightPos;
-
-	// add dynamic light when necessary
-	if(state->isActive ||(state->lightAmt > config->lightMin)){
-
+	if(state->isActive || state->lightAmt > config->lightMin){
+		vec3_t lightPos;
+		vec3_t color;
 		// Since lerpOrigin is the lightingOrigin for the player, this will add a backsplash light for the aura.
 		VectorAdd( player->lerpOrigin, cg.refdef.viewaxis[0], lightPos);
-
-		trap_R_AddLightToScene( lightPos, state->lightAmt, // +(cos(cg.time / 50.0f) * state->lightDev),
-								config->lightColor[0] * state->modulate,
-								config->lightColor[1] * state->modulate,
-								config->lightColor[2] * state->modulate);
+		VectorScale(config->lightColor,state->modulate,color);
+		trap_R_AddLightToScene( lightPos, state->lightAmt,color);
 	}
 }
 
Index: Game/CGame/cg_drawtools.c
===================================================================
--- Game/CGame/cg_drawtools.c	(revision 1956)
+++ Game/CGame/cg_drawtools.c	(working copy)
@@ -841,3 +841,25 @@
 
 	UI_DrawProportionalString2( x, y, str, color, sizeScale, cgs.media.charsetProp );
 }
+
+void CG_DrawLineRGBA(vec3_t start,vec3_t end,float width,qhandle_t shader,vec4_t color){
+	vec3_t line;
+	vec3_t offset;
+	vec3_t viewLine;
+	polyVert_t vertices[4];
+	float coordinates[] = {1,0,0,0,0,1,1,1};
+	int index;
+	VectorSubtract(end,start,line);
+	VectorSubtract(start,cg.refdef.vieworg,viewLine);
+	CrossProduct(viewLine,line,offset);
+	if(!VectorNormalize(offset)){return;}
+	VectorMA(end,-width,offset,vertices[0].xyz);
+	VectorMA(end,width,offset,vertices[1].xyz);
+	VectorMA(start,width,offset,vertices[2].xyz);
+	VectorMA(start,-width,offset,vertices[3].xyz);
+	for(index=0;index<4;++index){
+		Vector4Copy(color,vertices[index].modulate);
+		memcpy(vertices[index].st,&coordinates[index*2],sizeof(vertices[index].st));
+	}
+	trap_R_AddPolyToScene(shader,4,vertices);
+}
Index: Game/CGame/cg_ents.c
===================================================================
--- Game/CGame/cg_ents.c	(revision 1956)
+++ Game/CGame/cg_ents.c	(working copy)
@@ -272,17 +272,13 @@
 
 
 	// constant light glow
-	if(cent->currentState.constantLight)
-	{
-		int		cl;
-		float		i, r, g, b;
-
-		cl = cent->currentState.constantLight;
-		r = (float) (cl & 0xFF) / 255.0;
-		g = (float) ((cl >> 8) & 0xFF) / 255.0;
-		b = (float) ((cl >> 16) & 0xFF) / 255.0;
-		i = (float) ((cl >> 24) & 0xFF) * 4.0;
-		trap_R_AddLightToScene(cent->lerpOrigin, i, r, g, b);
+	if(cent->currentState.constantLight){
+		int cl = cent->currentState.constantLight;
+		vec3_t color;
+		float intensity = ((cl >> 24) & 0xff) * 4.0f;
+		VectorSet(color,cl & 0xff,(cl >> 8) & 0xff,(cl >> 16) & 0xff);
+		VectorScale(color,1/255,color);
+		trap_R_AddLightToScene(cent->lerpOrigin,intensity,color);
 	}
 
 }
@@ -367,6 +363,7 @@
 	int			beamPowerLevelCurrent;
 	int			beamPowerLevelTotal;
 	float		radiusScale;
+	vec4_t color = {255,255,255,255};
 
 	// Initialize some things for quick reference
 	es = &ent->currentState;
@@ -401,7 +398,7 @@
 	}
 
 	if ( CG_GetTagOrientationFromPlayerEntity( &cg_entities[es->clientNum], weaponGraphics->chargeTag[0], &orient )) {
-		CG_DrawLine (orient.origin, ent->lerpOrigin, radius, weaponGraphics->missileTrailShader, 1/*radiusScale*/);
+		CG_DrawLineRGBA (orient.origin, ent->lerpOrigin, radius, weaponGraphics->missileTrailShader, color/*radiusScale*/);
 	}
 }
 
@@ -776,12 +773,9 @@
 	}
 
 	// add dynamic light
-	if ( weaponGraphics->missileDlightRadius ) {
-		trap_R_AddLightToScene(cent->lerpOrigin,
-			100 * weaponGraphics->missileDlightRadius, 
-			weaponGraphics->missileDlightColor[0],
-			weaponGraphics->missileDlightColor[1],
-			weaponGraphics->missileDlightColor[2] );
+	if(weaponGraphics->missileDlightRadius){
+		float scale = 100 * weaponGraphics->missileDlightRadius;
+		trap_R_AddLightToScene(cent->lerpOrigin,scale,weaponGraphics->missileDlightColor);
 	}
 
 	// add missile sound
Index: Game/CGame/cg_local.h
===================================================================
--- Game/CGame/cg_local.h	(revision 1956)
+++ Game/CGame/cg_local.h	(working copy)
@@ -1053,10 +1053,9 @@
 void CG_AdjustFrom640( float *x, float *y, float *w, float *h,qboolean stretch);
 void CG_FillRect( float x, float y, float width, float height, const float *color );
 void CG_DrawPic(qboolean stretch, float x, float y, float width, float height, qhandle_t hShader );
-void CG_DrawString( float x, float y, const char *string, 
-				   float charWidth, float charHeight, const float *modulate );
+void CG_DrawString(float x,float y,const char* string,float charWidth,float charHeight,const float* modulate);
+void CG_DrawLineRGBA (vec3_t start, vec3_t end, float width, qhandle_t shader, vec4_t RGBA);
 
-
 void CG_DrawStringExt(int spacing, int x, int y, const char *string, const float *setColor, 
 		qboolean forceColor, qboolean shadow, int charWidth, int charHeight, int maxChars);
 void CG_DrawBigString( int x, int y, const char *s, float alpha );
@@ -1211,20 +1210,13 @@
 void CG_MissileHitWall( int weapon, int clientNum, vec3_t origin, vec3_t dir, impactSound_t soundType );
 void CG_MissileHitPlayer( int weapon, vec3_t origin, vec3_t dir, int entityNum );
 void CG_Bullet( vec3_t origin, int sourceEntityNum, vec3_t normal, qboolean flesh, int fleshEntityNum );
-void CG_Draw3DLine(const vec3_t start, const vec3_t end, qhandle_t shader);	// JUHOX
 
 void CG_RailTrail( clientInfo_t *ci, vec3_t start, vec3_t end );
 void CG_GrappleTrail( centity_t *ent, const weaponInfo_t *wi );
 void CG_AddViewWeapon (playerState_t *ps);
-void CG_AddPlayerWeapon( refEntity_t *parent, playerState_t *ps, centity_t *cent, int team );
+void CG_AddPlayerWeapon(refEntity_t* parent,centity_t* cent);
 void CG_DrawWeaponSelect( void );
 
-
-// FIXME: Should these be in drawtools instead?
-//        Should these be generalized for use in all manual poly drawing functions? (probably, yes...)
-void CG_DrawLine (vec3_t start, vec3_t end, float width, qhandle_t shader, float RGBModulate);
-void CG_DrawLineRGBA (vec3_t start, vec3_t end, float width, qhandle_t shader, vec4_t RGBA);
-
 void CG_UserMissileHitWall( int weapon, int clientNum, int powerups, int number, vec3_t origin, vec3_t dir, qboolean inAir );
 void CG_UserMissileHitPlayer( int weapon, int clientNum, int powerups, int number, vec3_t origin, vec3_t dir, int entityNum );
 void CG_UserRailTrail( int weapon, int clientNum, vec3_t start, vec3_t end);
@@ -1459,7 +1451,7 @@
 void		trap_R_AddPolyToScene( qhandle_t hShader , int numVerts, const polyVert_t *verts );
 void		trap_R_AddPolysToScene( qhandle_t hShader , int numVerts, const polyVert_t *verts, int numPolys );
 void		trap_R_AddFogToScene( float start, float end, float r, float g, float b, float opacity, float mode, float hint );
-void		trap_R_AddLightToScene( const vec3_t org, float intensity, float r, float g, float b );
+void		trap_R_AddLightToScene( const vec3_t org, float intensity,vec3_t color);
 int			trap_R_LightForPoint( vec3_t point, vec3_t ambientLight, vec3_t directedLight, vec3_t lightDir );
 void		trap_R_RenderScene( const refdef_t *fd );
 void		trap_R_SetColor( const float *rgba );	// NULL = 1,1,1,1
Index: Game/CGame/cg_localents.c
===================================================================
--- Game/CGame/cg_localents.c	(revision 1956)
+++ Game/CGame/cg_localents.c	(working copy)
@@ -261,29 +261,14 @@
 ====================
 */
 void CG_AddFadeNo( localEntity_t *le ) {
-	refEntity_t *re;
-	float		c;
-
-	re = &le->refEntity;
-
-	re->shaderRGBA[0] = le->color[0] * 0xff;
-	re->shaderRGBA[1] = le->color[1] * 0xff;
-	re->shaderRGBA[2] = le->color[2] * 0xff;
-
-	trap_R_AddRefEntityToScene( re );
-
-	// add the dlight
-	if ( le->light ) {
-		float		light;
-
-		light = (float)( cg.time - le->startTime ) / ( le->endTime - le->startTime );
-		if ( light < 0.5 ) {
-			light = 1.0;
-		} else {
-			light = 1.0 - ( light - 0.5 ) * 2;
-		}
+	refEntity_t* re = &le->refEntity;
+	VectorScale(le->color,255,re->shaderRGBA);
+	trap_R_AddRefEntityToScene(re);
+	if(le->light){
+		float light = (float)(cg.time - le->startTime) / (le->endTime - le->startTime);
+		light = light < 0.5f ? 1.0f : 1.0f - (light - 0.5f) * 2.0f;
 		light = le->light * light;
-		trap_R_AddLightToScene(re->origin, light, le->lightColor[0], le->lightColor[1], le->lightColor[2] );
+		trap_R_AddLightToScene(re->origin,light,le->lightColor);
 	}
 }
 
@@ -480,25 +465,13 @@
 ================
 */
 static void CG_AddExplosion( localEntity_t *ex ) {
-	refEntity_t	*ent;
-
-	ent = &ex->refEntity;
-
-	// add the entity
+	refEntity_t* ent = &ex->refEntity;
 	trap_R_AddRefEntityToScene(ent);
-
-	// add the dlight
-	if ( ex->light ) {
-		float		light;
-
-		light = (float)( cg.time - ex->startTime ) / ( ex->endTime - ex->startTime );
-		if ( light < 0.5 ) {
-			light = 1.0;
-		} else {
-			light = 1.0 - ( light - 0.5 ) * 2;
-		}
+	if(ex->light){
+		float light = (float)(cg.time - ex->startTime) / (ex->endTime - ex->startTime);
+		light = light < 0.5f ? 1.0f : 1.0f - (light - 0.5f) * 2.0f;
 		light = ex->light * light;
-		trap_R_AddLightToScene(ent->origin, light, ex->lightColor[0], ex->lightColor[1], ex->lightColor[2] );
+		trap_R_AddLightToScene(ent->origin,light,ex->lightColor);
 	}
 }
 
@@ -510,12 +483,11 @@
 */
 static void CG_AddStraightBeamFade( localEntity_t *le ) {
 	refEntity_t	*ent;		// reference entity stored in the local entity
-	float		RGBfade;	// stores the amount of fade to apply to the RGBA values
 	float		scale_l;	// stores the scale factor for the beam's length
 	float		scale_w;	// stores the scale factor for the beam's width
 	vec3_t		start;		// temporary storage for the beam's start point
 	vec3_t		direction;	// vector used in calculating the shortening of the beam
-	
+	vec4_t color;
 	// set up for quick reference
 	ent = &le->refEntity;
 
@@ -522,20 +494,20 @@
 	// Save the start vector so it can be recovered after having been rendered.
 	VectorCopy( ent->origin, start );
 
-	// calculate RGBfade and scale
-	RGBfade = 1 - (float)( cg.time - le->startTime ) / ( le->endTime - le->startTime );
-	scale_l = RGBfade;
+	scale_l = 1 - (float)( cg.time - le->startTime ) / ( le->endTime - le->startTime );
 	scale_w = 1 - (float)( cg.time - le->startTime ) / ( le->endTime - le->startTime );
 	if (scale_w < 0) {
 		scale_w = 0;
 	}
-	
+	VectorSet(color,scale_l,scale_l,scale_l);
+	VectorScale(color,255,color);
+	color[3] = scale_l * 255;
 	// Set the scaled beam
 	VectorSubtract( ent->origin, ent->oldorigin, direction);
 	VectorScale(direction, scale_l, direction);
 	VectorAdd(ent->oldorigin, direction, ent->origin);
 
-	CG_DrawLine (ent->origin, ent->oldorigin, le->radius * scale_w, ent->customShader, RGBfade);
+	CG_DrawLineRGBA(ent->origin,ent->oldorigin,le->radius * scale_w,ent->customShader,color);
 
 	// Restore the start vector
 	VectorCopy(start, ent->origin);
@@ -600,19 +572,14 @@
 	VectorCopy(tmpAxes[1], ent->axis[1]);
 	VectorCopy(tmpAxes[2], ent->axis[2]);
 
-	// add a Dlight
-	if ( le->light ) {
-		float light;
+	if(le->light){
+		float light = (float)(cg.time - le->startTime) / (le->endTime - le->startTime);
 		float lightRad;
-
-		light = (float)( cg.time - le->startTime ) / ( le->endTime - le->startTime );
-		if ( light < 0.5 ) {
-			light = light * 2;
-		} else {
-			light = 1.0 - ( light - 0.5 ) * 2;
-		}
+		vec3_t color;
+		light = light < 0.5f ? light * 2.0f : 1.0f - (light - 0.5f) * 2.0f;
 		lightRad = le->light * light;
-		trap_R_AddLightToScene(ent->origin, lightRad, light * le->lightColor[0], light * le->lightColor[1], light * le->lightColor[2] );
+		VectorScale(le->lightColor,light,color);
+		trap_R_AddLightToScene(ent->origin,lightRad,color);
 	}
 }
 
@@ -690,19 +657,12 @@
 	re.radius = 42 * ( 1.0 - c ) + 30;
 
 	trap_R_AddRefEntityToScene( &re );
-
-	// add the dlight
-	if ( le->light ) {
-		float		light;
-
-		light = (float)( cg.time - le->startTime ) / ( le->endTime - le->startTime );
-		if ( light < 0.5 ) {
-			light = 1.0;
-		} else {
-			light = 1.0 - ( light - 0.5 ) * 2;
-		}
+	
+	if(le->light){
+		float light = (float)(cg.time - le->startTime) / (le->endTime - le->startTime);
+		light = light < 0.5f ? 1.0f : 1.0f - (light - 0.5f) * 2.0f;
 		light = le->light * light;
-		trap_R_AddLightToScene(re.origin, light, le->lightColor[0], le->lightColor[1], le->lightColor[2] );
+		trap_R_AddLightToScene(re.origin,light,le->lightColor);
 	}
 }
 
Index: Game/CGame/cg_players.c
===================================================================
--- Game/CGame/cg_players.c	(revision 1956)
+++ Game/CGame/cg_players.c	(working copy)
@@ -1042,7 +1042,7 @@
 	memcpy( &playerInfoDuplicate[cent->currentState.number], &cent->pe, sizeof(playerEntity_t));
 	if(onBodyQue){return;}
 	CG_Camera(cent);
-	CG_AddPlayerWeapon(&torso,NULL,cent,ci->team);
+	CG_AddPlayerWeapon(&torso,cent);
 	CG_PlayerPowerups(cent,&torso);
 	if((cent->currentState.eFlags & EF_AURA) || ci->auraConfig[tier]->auraAlways){
 		CG_AuraStart(cent);
Index: Game/CGame/cg_syscalls.c
===================================================================
--- Game/CGame/cg_syscalls.c	(revision 1956)
+++ Game/CGame/cg_syscalls.c	(working copy)
@@ -274,8 +274,8 @@
 	syscall( CG_R_ADDFOGTOSCENE, PASSFLOAT(start), PASSFLOAT(end), PASSFLOAT(r), PASSFLOAT(g), PASSFLOAT(b), PASSFLOAT(opacity), PASSFLOAT(mode), PASSFLOAT(hint) );
 }
 
-void	trap_R_AddLightToScene( const vec3_t org, float intensity, float r, float g, float b ) {
-	syscall( CG_R_ADDLIGHTTOSCENE, org, PASSFLOAT(intensity), PASSFLOAT(r), PASSFLOAT(g), PASSFLOAT(b) );
+void trap_R_AddLightToScene(const vec3_t org,float intensity,vec3_t color){
+	syscall(CG_R_ADDLIGHTTOSCENE,org,PASSFLOAT(intensity),PASSFLOAT(color[0]),PASSFLOAT(color[1]),PASSFLOAT(color[2]));
 }
 
 void	trap_R_AddAdditiveLightToScene( const vec3_t org, float intensity, float r, float g, float b ) {
Index: Game/CGame/cg_userweapons.h
===================================================================
--- Game/CGame/cg_userweapons.h	(revision 1956)
+++ Game/CGame/cg_userweapons.h	(working copy)
@@ -1,7 +1,10 @@
-#define MAX_CHARGES			 2
-#define MAX_TAGNAME			20
-#define MAX_WEAPONNAME		40
-#define MAX_CHARGE_VOICES	 6
+#define MAX_CHARGES 2
+#define MAX_TAGNAME 20
+#define MAX_WEAPONNAME 40
+#define MAX_CHARGE_VOICES 6
+#define MAX_FLASH_VOICES 4
+#define MAX_FLASH_SOUNDS 4
+#define MAX_EXPLOSION_SOUNDS 4
 typedef struct {
 	sfxHandle_t		voice;
 	float			startPct;
@@ -43,10 +46,10 @@
 	float			flashSize;				// If the weapon was charged, multiply with chargeSize;
 	float			flashDlightRadius;		// radius of light
 	vec3_t			flashDlightColor;		// color of light
-	sfxHandle_t		flashSound[4];			// if more than one is specified, a random one	
+	sfxHandle_t		flashSound[MAX_FLASH_SOUNDS];			// if more than one is specified, a random one	
 											// is chosen. (Breaks repetitiveness for
 											// fastfiring weapons)
-	sfxHandle_t		voiceSound[4];
+	sfxHandle_t		voiceSound[MAX_FLASH_VOICES];
 	sfxHandle_t		flashOnceSound;			// Played only at the start of a firing session, instead
 											// of with each projectile. Resets when attack button comes up.
 	sfxHandle_t		firingSound;			// When doing a sustained blast
@@ -87,7 +90,7 @@
 	qhandle_t		markSize;
 	qboolean		noRockDebris;
 
-	sfxHandle_t		explosionSound[4];		// if more than one is specified, a random one	
+	sfxHandle_t		explosionSound[MAX_EXPLOSION_SOUNDS];		// if more than one is specified, a random one	
 											// is chosen. (Breaks repetitiveness for
 											// fastfiring weapons)
 	// HUD
@@ -151,10 +154,10 @@
 	float			flashDlightRadius;		// radius of light
 	vec3_t			flashDlightColor;		// color of light
 	
-	char			flashSound[4][MAX_QPATH];	// if more than one is specified, a random one	
+	char			flashSound[MAX_FLASH_SOUNDS][MAX_QPATH];	// if more than one is specified, a random one	
 												// is chosen. (Breaks repetitiveness for
 												// fastfiring weapons)
-	char			voiceSound[4][MAX_QPATH];
+	char			voiceSound[MAX_FLASH_VOICES][MAX_QPATH];
 	char			flashOnceSound[MAX_QPATH];	// Played only at the start of a firing session, instead
 												// of with each projectile. Resets when attack button comes up.
 	char			firingSound[MAX_QPATH];		// When doing a sustained blast
@@ -210,7 +213,7 @@
 	qhandle_t		markSize;
 	qboolean		noRockDebris;
 
-	char			explosionSound[4][MAX_QPATH];	// if more than one is specified, a random one	
+	char			explosionSound[MAX_EXPLOSION_SOUNDS][MAX_QPATH];	// if more than one is specified, a random one	
 													// is chosen. (Breaks repetitiveness for
 													// fastfiring weapons)
 	// HUD
Index: Game/CGame/cg_weapGfxParser.c
===================================================================
--- Game/CGame/cg_weapGfxParser.c	(revision 1956)
+++ Game/CGame/cg_weapGfxParser.c	(working copy)
@@ -11,11 +11,9 @@
 // into qhandle_t in the process.
 //=========================================
 void CG_weapGfx_StoreBuffer(int clientNum,int weaponNum){
-	cg_userWeapon_t* dest;
-	cg_userWeaponParseBuffer_t* src;
+	cg_userWeapon_t* dest = CG_FindUserWeaponGraphics(clientNum,weaponNum + 1);
+	cg_userWeaponParseBuffer_t* src = &cg_weapGfxBuffer;
 	int i;
-	src = &cg_weapGfxBuffer;
-	dest = CG_FindUserWeaponGraphics(clientNum,weaponNum + 1);
 	memset(dest,0,sizeof(cg_userWeapon_t));
 	// --< Charge >--
 	if(*src->chargeModel){dest->chargeModel = trap_R_RegisterModel(src->chargeModel);}
@@ -22,7 +20,7 @@
 	if(*src->chargeSkin){dest->chargeSkin = trap_R_RegisterSkin(src->chargeSkin);}
 	if(*src->chargeShader){dest->chargeShader = trap_R_RegisterShader(src->chargeShader);}
 	if(*src->chargeLoopSound){dest->chargeLoopSound = trap_S_RegisterSound(src->chargeLoopSound,qfalse);}
-	for(i=0;i<6;i++){
+	for(i=0;i<MAX_CHARGE_VOICES;i++){
 		if(!*src->chargeVoice[i].voice){continue;}
 		dest->chargeVoice[i].voice = trap_S_RegisterSound(src->chargeVoice[i].voice,qfalse);
 		dest->chargeVoice[i].startPct = src->chargeVoice[i].startPct;
@@ -44,8 +42,10 @@
 	if(*src->flashShader){dest->flashShader = trap_R_RegisterShader(src->flashShader);}
 	if(*src->firingSound){dest->firingSound = trap_S_RegisterSound(src->firingSound,qfalse);}
 	if(*src->flashOnceSound){dest->flashOnceSound = trap_S_RegisterSound(src->flashOnceSound,qfalse);}
-	for(i=0;i<4;i++){
+	for(i=0;i<MAX_FLASH_SOUNDS;i++){
 		if(*src->flashSound[i]){dest->flashSound[i] = trap_S_RegisterSound(src->flashSound[i],qfalse);}
+	}
+	for(i=0;i<MAX_FLASH_VOICES;i++){
 		if(*src->voiceSound[i]){dest->voiceSound[i] = trap_S_RegisterSound(src->voiceSound[i],qfalse);}
 	}
 	VectorCopy(src->flashDlightColor,dest->flashDlightColor);
@@ -60,9 +60,8 @@
 	if(*src->shockwaveModel){dest->shockwaveModel = trap_R_RegisterModel(src->shockwaveModel);}
 	if(*src->shockwaveSkin){dest->shockwaveSkin = trap_R_RegisterSkin(src->shockwaveSkin);}
 	if(*src->markShader){dest->markShader = trap_R_RegisterShader(src->markShader);}
-	for(i=0;i<4;i++){
-		if(!*src->explosionSound[i]){continue;}
-		dest->explosionSound[i] = trap_S_RegisterSound(src->explosionSound[i],qfalse);
+	for(i=0;i<MAX_EXPLOSION_SOUNDS;i++){
+		if(*src->explosionSound[i]){dest->explosionSound[i] = trap_S_RegisterSound(src->explosionSound[i],qfalse);}
 	}
 	VectorCopy(src->explosionDlightColor,dest->explosionDlightColor);
 	dest->explosionDlightRadius = src->explosionDlightRadius;
@@ -105,11 +104,9 @@
 qboolean CG_weapGfx_ParseDummy(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){return qfalse;}
 // Syntax: 'model' '=' ( "filename" | null )
 qboolean CG_weapGfx_ParseModel(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	char* weaponField;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_CHARGE){weaponField = cg_weapGfxBuffer.chargeModel;}
 	else if(category == CAT_EXPLOSION){weaponField = cg_weapGfxBuffer.explosionModel;}
 	else if(category == CAT_STRUGGLE){weaponField = cg_weapGfxBuffer.missileStruggleModel;}
@@ -129,11 +126,9 @@
 }
 // Syntax: 'skin' '=' ( "filename" | 'null' )
 qboolean CG_weapGfx_ParseSkin(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	char* weaponField;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_CHARGE){weaponField = cg_weapGfxBuffer.chargeSkin;}
 	else if(category == CAT_EXPLOSION){weaponField = cg_weapGfxBuffer.explosionSkin;}
 	else if(category == CAT_STRUGGLE){weaponField = cg_weapGfxBuffer.missileStruggleSkin;}
@@ -153,11 +148,9 @@
 }
 // Syntax: 'shader' '=' ( "filename" | 'null' )
 qboolean CG_weapGfx_ParseShader(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	char* weaponField;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_CHARGE){weaponField = cg_weapGfxBuffer.chargeShader;}
 	else if(category == CAT_EXPLOSION){weaponField = cg_weapGfxBuffer.explosionShader;}
 	else if(category == CAT_STRUGGLE){weaponField = cg_weapGfxBuffer.missileStruggleShader;}
@@ -178,10 +171,8 @@
 }
 // Syntax: 'animationRange' '=' ( '[' <int> <int> ']' | <int> )
 qboolean CG_weapGfx_ParseAnimationRange(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_CHARGE){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -203,7 +194,7 @@
 		if(token->tokenSym != TOKEN_INTEGER){return CG_weapGfx_ErrorHandle(ERROR_INTEGER_EXPECTED,scanner,token->stringval,NULL);}
 		// NOTE: This is the only range that must NOT be inverted.
 		if(token->intval < cg_weapGfxBuffer.chargeStartPct){
-			return CG_weapGfx_ErrorHandle(ERROR_INVERTED_RANGE,scanner,token->stringval,va("%s",cg_weapGfxBuffer.chargeStartPct));
+			return CG_weapGfx_ErrorHandle(ERROR_INVERTED_RANGE,scanner,token->stringval,va("%d",cg_weapGfxBuffer.chargeStartPct));
 		}
 		if(token->intval > 100){return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXBOUND,scanner,token->stringval,"100");}
 		if(token->intval < 0){return CG_weapGfx_ErrorHandle(ERROR_UNDER_MINBOUND,scanner,token->stringval,"0");}
@@ -220,11 +211,9 @@
 }
 // Syntax: 'size' '=' ( <int> | <float> )  |  ( '[' ( <int> | float ) ( <int> | <float> ']' )
 qboolean CG_weapGfx_ParseSize(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	float* size;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_CHARGE){
 		if(token->tokenSym == TOKEN_INTEGER || token->tokenSym == TOKEN_FLOAT){
 			cg_weapGfxBuffer.chargeStartsize = token->floatval;
@@ -266,14 +255,12 @@
 }
 // Syntax: 'light' '=' '(' <i>|<f>  <i>|<f>  <i>|<f> ')' (   ( <i>|<f> )  |  ( '[' <i>|<f>  <i>|<f> ']' )   )
 qboolean CG_weapGfx_ParseDlight(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	float* floatField;
 	vec3_t* colorField;
 	vec3_t RGB;
 	int channel;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category != CAT_CHARGE && category != CAT_EXPLOSION && category != CAT_MISSILE && category != CAT_FLASH){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -342,12 +329,10 @@
 }
 // Syntax: 'spin' '=' '(' <i>|<f>  <i>|<f>  <i>|<f> ')'
 qboolean CG_weapGfx_ParseSpin(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	vec3_t	spin;
 	int axis;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category != CAT_CHARGE && category != CAT_MISSILE){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -373,10 +358,8 @@
 // Syntax: 'tagTo' '=' "tagname"
 // FIXME: Should become later: 'tagTo' '=' ( "tagname" | 'null' ) ( "tagname" | 'null' )
 qboolean CG_weapGfx_ParseTagTo(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_CHARGE){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -392,18 +375,17 @@
 }
 // Syntax: 'soundFx' '=' ( 'null' | "filename" | '(' "filename"* ')' )
 qboolean CG_weapGfx_ParseSoundFx(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
+	int maximumSounds = category == CAT_EXPLOSION ? MAX_EXPLOSION_SOUNDS : MAX_FLASH_SOUNDS;
 	int index = 0;
 	char (*sound)[MAX_QPATH];
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_EXPLOSION){sound = cg_weapGfxBuffer.explosionSound;}
 	else if(category == CAT_FLASH){sound = cg_weapGfxBuffer.flashSound;}
 	else{
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
-	memset(sound,0,4*MAX_QPATH);
+	memset(sound,0,MAX_QPATH * maximumSounds);
 	if(token->tokenSym == TOKEN_STRING){
 		Q_strncpyz(sound[0],token->stringval,MAX_QPATH);
 	}
@@ -410,8 +392,8 @@
 	else if(token->tokenSym == TOKEN_OPENVECTOR){
 		if(!CG_weapGfx_CheckPrematureEOF(scanner,token)){return qfalse;}
 		while(token->tokenSym == TOKEN_STRING){
-			if(index >= 4){
-				return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXVECTORELEMS,scanner,token->stringval,"4");
+			if(index >= maximumSounds){
+				return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXVECTORELEMS,scanner,token->stringval,va("%d",maximumSounds));
 			}
 			Q_strncpyz(sound[index],token->stringval,MAX_QPATH);
 			index++;
@@ -428,15 +410,13 @@
 }
 // Syntax: 'voiceFx' '=' ( 'null' | "filename" | '(' "filename"* ')' )
 qboolean CG_weapGfx_ParseVoiceFx(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	int index = 0;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category != CAT_FLASH){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
-	memset(cg_weapGfxBuffer.voiceSound,0,4*MAX_QPATH);
+	memset(cg_weapGfxBuffer.voiceSound,0,MAX_QPATH * MAX_FLASH_VOICES);
 	if(token->tokenSym == TOKEN_STRING){
 		Q_strncpyz(cg_weapGfxBuffer.voiceSound[0],token->stringval,sizeof(cg_weapGfxBuffer.voiceSound[0]));
 	}
@@ -443,8 +423,8 @@
 	else if(token->tokenSym == TOKEN_OPENVECTOR){
 		if(!CG_weapGfx_CheckPrematureEOF(scanner,token)){return qfalse;}
 		while(token->tokenSym == TOKEN_STRING){
-			if(index >= 4){
-				return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXVECTORELEMS,scanner,token->stringval,"4");
+			if(index >= MAX_FLASH_VOICES){
+				return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXVECTORELEMS,scanner,token->stringval,va("%d",MAX_FLASH_VOICES));
 			}
 			Q_strncpyz(cg_weapGfxBuffer.voiceSound[index],token->stringval,sizeof(cg_weapGfxBuffer.voiceSound[index]));
 			index++;
@@ -461,11 +441,9 @@
 }
 // Syntax: 'loopFx' '=' ( "filename" | 'null' )
 qboolean CG_weapGfx_ParseLoopFx(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	char* sound;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_CHARGE){sound = cg_weapGfxBuffer.chargeLoopSound;}
 	else if(category == CAT_MISSILE){sound = cg_weapGfxBuffer.missileSound;}
 	else if(category == CAT_FLASH){sound = cg_weapGfxBuffer.firingSound;}
@@ -483,15 +461,13 @@
 }
 // Syntax: 'timedFx' '=' ( ( '(' ( <i> "filename" )* ')' ) | 'null' )
 qboolean CG_weapGfx_ParseTimedFx(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	int i=0;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category != CAT_CHARGE){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
-	memset(cg_weapGfxBuffer.chargeVoice,0,sizeof(chargeVoiceParseBuffer_t)*6);
+	memset(cg_weapGfxBuffer.chargeVoice,0,sizeof(chargeVoiceParseBuffer_t) * MAX_CHARGE_VOICES);
 	// Don't have to do anything but blank it out and advance the token, if 'null' was passed.
 	if(token->tokenSym == TOKEN_NULL){
 		return CG_weapGfx_CheckPrematureEOF(scanner,token);
@@ -501,7 +477,7 @@
 	}
 	if(!CG_weapGfx_CheckPrematureEOF(scanner,token)){return qfalse;}
 	while(token->tokenSym == TOKEN_INTEGER){
-		if(i >= 6){return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXVECTORELEMS,scanner,token->stringval,"6");}
+		if(i >= MAX_CHARGE_VOICES){return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXVECTORELEMS,scanner,token->stringval,va("%d",MAX_CHARGE_VOICES));}
 		if(token->intval > 100){return CG_weapGfx_ErrorHandle(ERROR_OVER_MAXBOUND,scanner,token->stringval,"100");}
 		if(token->intval < 0){return CG_weapGfx_ErrorHandle(ERROR_UNDER_MINBOUND,scanner,token->stringval,"0");}
 		cg_weapGfxBuffer.chargeVoice[i].startPct = token->intval;
@@ -520,10 +496,8 @@
 }
 // Syntax: 'onceFx' '=' ( "filename" | 'null' )
 qboolean CG_weapGfx_ParseOnceFx(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_FLASH){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -538,10 +512,8 @@
 }
 // Syntax: 'duration' '=' <int>
 qboolean CG_weapGfx_ParseDuration(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_EXPLOSION){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -553,10 +525,8 @@
 }
 // Syntax: 'shockwave' '=' ( ("filename" "filename") | null )
 qboolean CG_weapGfx_ParseShockwave(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_EXPLOSION){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -579,10 +549,8 @@
 }
 // Syntax: 'markShader' '=' ( "filename" | null )
 qboolean CG_weapGfx_ParseMarkShader(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_EXPLOSION){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -597,10 +565,8 @@
 }
 // Syntax: 'markSize' '=' <int>
 qboolean CG_weapGfx_ParseMarkSize(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_EXPLOSION){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -612,10 +578,8 @@
 }
 // Syntax: 'noRockDebris' '=' <int>
 qboolean CG_weapGfx_ParseRockDebris(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_EXPLOSION){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -627,10 +591,8 @@
 }
 // Syntax: 'smokeParticles' '=' "system name" | 'null'
 qboolean CG_weapGfx_ParseSmokeParticles(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_EXPLOSION){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -645,11 +607,9 @@
 }
 // Syntax: 'loopParticles' '=' "system name" | 'null'
 qboolean CG_weapGfx_ParseLoopParticles(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	char* systemField;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_CHARGE){systemField = cg_weapGfxBuffer.chargeParticleSystem;}
 	else if(category == CAT_FLASH){systemField = cg_weapGfxBuffer.firingParticleSystem;}
 	else{
@@ -666,11 +626,9 @@
 }
 // Syntax: 'particles' '=' "system name" | 'null'
 qboolean CG_weapGfx_ParseParticles(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	char* systemField;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(category == CAT_EXPLOSION){systemField = cg_weapGfxBuffer.explosionParticleSystem;}
 	else if(category == CAT_MISSILE){systemField = cg_weapGfxBuffer.missileParticleSystem;}
 	else if(category == CAT_FLASH){systemField = cg_weapGfxBuffer.flashParticleSystem;}
@@ -688,10 +646,8 @@
 }
 // Syntax: 'spiralShader' '=' ( "filename" | 'null' )
 qboolean CG_weapGfx_ParseSpiralShader(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_TRAIL){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -706,10 +662,8 @@
 }
 // Syntax: 'spiralSize' '=' (<int> | <float>)
 qboolean CG_weapGfx_ParseSpiralSize(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_TRAIL){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -721,10 +675,8 @@
 }
 // Syntax: 'spiralOffset' '=' (<int> | <float>)
 qboolean CG_weapGfx_ParseSpiralOffset(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_TRAIL){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -736,10 +688,8 @@
 }
 // Syntax: 'icon' '=' ( "filename" | 'null' )
 qboolean CG_weapGfx_ParseIcon(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_HUD){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -754,10 +704,8 @@
 }
 // Syntax: 'displayName' '=' ( "filename" | 'null' )
 qboolean CG_weapGfx_ParseDisplayName(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category,int field){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	if(category != CAT_HUD){
 		return CG_weapGfx_ErrorHandle(ERROR_FIELD_NOT_IN_CATEGORY,scanner,cg_weapGfxFields[field].fieldname,cg_weapGfxCategories[category]);
 	}
@@ -776,12 +724,10 @@
 // Stores import definitions in a reference list.
 // Syntax: 'import' "<refname>" '=' "<filename>" "<defname>"
 static qboolean CG_weapGfx_ParseImports(cg_weapGfxParser_t* parser){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	char refname[MAX_TOKENSTRING_LENGTH];
 	char filename[MAX_TOKENSTRING_LENGTH];
-	scanner = &parser->scanner;
-	token = &parser->token;
 	while(token->tokenSym == TOKEN_IMPORT){
 		if(!CG_weapGfx_CheckPrematureEOF(scanner,token)){return qfalse;}
 		if(token->tokenSym != TOKEN_STRING){
@@ -814,10 +760,8 @@
 	return qtrue;
 }
 static qboolean CG_weapGfx_ParseFields(cg_weapGfxParser_t* parser,cg_weapGfxCategoryIndex_t category){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	while(token->tokenSym == TOKEN_FIELD){
 		int field = token->identifierIndex;
 		if(!CG_weapGfx_CheckPrematureEOF(scanner,token)){return qfalse;}
@@ -833,10 +777,8 @@
 }
 // Syntax: <categoryname> '{' <HANDLE FIELDS> '}'
 static qboolean CG_weapGfx_ParseCategories(cg_weapGfxParser_t* parser){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
-	scanner = &parser->scanner;
-	token = &parser->token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	while(token->tokenSym == TOKEN_CATEGORY){
 		int currentCategory = token->identifierIndex;
 		if(!CG_weapGfx_CheckPrematureEOF(scanner,token)){return qfalse;}
@@ -868,8 +810,8 @@
 // we find out the links in CG_weapGfx_ParseLinks.
 // Syntax: ( 'public' | 'protected' | 'private' ) "<refname>" ( e | '=' ( "<importref>" | "<definitionref>" ) ) '{' <HANDLE CATEGORIES> '}'
 static qboolean CG_weapGfx_PreParseDefinitions(cg_weapGfxParser_t* parser){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	int defline;
 	char* defpos;
 	qboolean hasSuper;
@@ -876,8 +818,6 @@
 	char supername[MAX_TOKENSTRING_LENGTH];
 	char refname[MAX_TOKENSTRING_LENGTH];
 	int blockCount;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	while(token->tokenSym == TOKEN_PRIVATE || token->tokenSym == TOKEN_PUBLIC || token->tokenSym == TOKEN_PROTECTED){
 		cg_weapGfxAccessLvls_t accessLvl = LVL_PRIVATE;
 		if(token->tokenSym == TOKEN_PUBLIC){accessLvl = LVL_PUBLIC;}
@@ -928,13 +868,11 @@
 // Parses weapon links to definitions and continues to parse the actual weapon definitions.
 // Syntax: 'weapon' <int> '=' "<refname>" ( e | '|' "<refname>" )
 static qboolean CG_weapGfx_ParseLinks(cg_weapGfxParser_t* parser){
-	cg_weapGfxToken_t* token;
-	cg_weapGfxScanner_t* scanner;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	int weaponNum;
 	char pri_refname[MAX_TOKENSTRING_LENGTH];
 	char sec_refname[MAX_TOKENSTRING_LENGTH];
-	scanner = &parser->scanner;
-	token = &parser->token;
 	while(token->tokenSym == TOKEN_WEAPON){
 		if(!CG_weapGfx_CheckPrematureEOF(scanner,token)){return qfalse;}
 		if(token->tokenSym != TOKEN_INTEGER){
@@ -1028,12 +966,10 @@
 // Takes inheritance into account.
 qboolean CG_weapGfx_ParseDefinition(cg_weapGfxParser_t* parser,char* refname,cg_weapGfxAccessLvls_t* accessLvl){
 	int i = CG_weapGfx_FindDefinitionRef(parser,refname) - 1;
-	cg_weapGfxScanner_t* scanner;
-	cg_weapGfxToken_t* token;
+	cg_weapGfxScanner_t* scanner = &parser->scanner;
+	cg_weapGfxToken_t* token = &parser->token;
 	// <-- Incase there IS no last access level from a super class
 	cg_weapGfxAccessLvls_t lastAccessLvl = LVL_PUBLIC;
-	scanner = &parser->scanner;
-	token = &parser->token;
 	if(i < MAX_DEFINES){
 		// local declaration
 		if(parser->definitionRef[i].hasSuper){
Index: Game/CGame/cg_weapons.c
===================================================================
--- Game/CGame/cg_weapons.c	(revision 1956)
+++ Game/CGame/cg_weapons.c	(working copy)
@@ -19,1158 +19,324 @@
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ===========================================================================
 */
-//
 // cg_weapons.c -- events and effects dealing with weapons
 #include "cg_local.h"
-
-/*
-=============
-CG_DrawLine
-=============
-*/
-void CG_DrawLine (vec3_t start, vec3_t end, float width, qhandle_t shader, float RGBModulate) {
-	vec3_t line, offset, viewLine;
-	polyVert_t verts[4];
-	float len;
-	int i, j;
-	
-	VectorSubtract (end, start, line);
-	VectorSubtract (start, cg.refdef.vieworg, viewLine);
-	CrossProduct (viewLine, line, offset);
-	len = VectorNormalize (offset);
-	
-	if (!len) {
-		return;
-	}
-	
-	VectorMA (end, -width, offset, verts[0].xyz);
-	verts[0].st[0] = 1;
-	verts[0].st[1] = 0;
-	VectorMA (end, width, offset, verts[1].xyz);
-	verts[1].st[0] = 0;
-	verts[1].st[1] = 0;
-	VectorMA (start, width, offset, verts[2].xyz);
-	verts[2].st[0] = 0;
-	verts[2].st[1] = 1;
-	VectorMA (start, -width, offset, verts[3].xyz);
-	verts[3].st[0] = 1;
-	verts[3].st[1] = 1;
-	
-	for (i = 0; i < 4; i++) {
-		for (j = 0; j < 4; j++) {
-			verts[i].modulate[j] = 255 * RGBModulate;
-		}
-	}
-
-	trap_R_AddPolyToScene( shader, 4, verts);
-}
-
-void CG_DrawLineRGBA (vec3_t start, vec3_t end, float width, qhandle_t shader, vec4_t RGBA) {
-	vec3_t line, offset, viewLine;
-	polyVert_t verts[4];
-	float len;
-	int i, j;
-	
-	VectorSubtract (end, start, line);
-	VectorSubtract (start, cg.refdef.vieworg, viewLine);
-	CrossProduct (viewLine, line, offset);
-	len = VectorNormalize (offset);
-	
-	if (!len) {
-		return;
-	}
-	
-	VectorMA (end, -width, offset, verts[0].xyz);
-	verts[0].st[0] = 1;
-	verts[0].st[1] = 0;
-	VectorMA (end, width, offset, verts[1].xyz);
-	verts[1].st[0] = 0;
-	verts[1].st[1] = 0;
-	VectorMA (start, width, offset, verts[2].xyz);
-	verts[2].st[0] = 0;
-	verts[2].st[1] = 1;
-	VectorMA (start, -width, offset, verts[3].xyz);
-	verts[3].st[0] = 1;
-	verts[3].st[1] = 1;
-	
-	for (i = 0; i < 4; i++) {
-		for (j = 0; j < 4; j++) {
-			verts[i].modulate[j] = RGBA[j];
-		}
-	}
-
-	trap_R_AddPolyToScene( shader, 4, verts);
-}
-
 /*========================================================================================
 VIEW WEAPON
 ========================================================================================*/
-
-/*=================
-CG_MapTorsoToWeaponFrame
-=================*/
-static int CG_MapTorsoToWeaponFrame( clientInfo_t *ci, int frame ) {
-/*
-	// change weapon
-	if ( frame >= ci->animations[ANIM_DROP].firstFrame 
-		&& frame < ci->animations[ANIM_DROP].firstFrame + 9 ) {
-		return frame - ci->animations[ANIM_DROP].firstFrame + 6;
-	}
-
-	// stand attack
-	if ( frame >= ci->animations[ANIM_ATTACK].firstFrame 
-		&& frame < ci->animations[ANIM_ATTACK].firstFrame + 6 ) {
-		return 1 + frame - ci->animations[ANIM_ATTACK].firstFrame;
-	}
-
-	// stand attack 2
-	if ( frame >= ci->animations[ANIM_ATTACK2].firstFrame 
-		&& frame < ci->animations[ANIM_ATTACK2].firstFrame + 6 ) {
-		return 1 + frame - ci->animations[ANIM_ATTACK2].firstFrame;
-	}
-*/
-	return 0;
+static void CG_SetWeaponSprite(refEntity_t* entity,float scale,qhandle_t shader){
+	entity->reType = RT_SPRITE;
+	entity->radius = 4 * scale;
+	entity->rotation = 0;
+	entity->customShader = shader;
 }
-
-
-/*
-==============
-CG_CalculateWeaponPosition
-==============
-*/
-static void CG_CalculateWeaponPosition( vec3_t origin, vec3_t angles ) {
-	float	scale;
-	int		delta;
-	float	fracsin;
-
-	VectorCopy( cg.refdef.vieworg, origin );
-	VectorCopy( cg.refdefViewAngles, angles );
-
-	// on odd legs, invert some angles
-	if ( cg.bobcycle & 1 ) {
-		scale = -cg.xyspeed;
-	} else {
-		scale = cg.xyspeed;
-	}
-
-	// gun angles from bobbing
-	angles[ROLL] += scale * cg.bobfracsin * 0.005;
-	angles[YAW] += scale * cg.bobfracsin * 0.01;
-	angles[PITCH] += cg.xyspeed * cg.bobfracsin * 0.005;
-
-	// drop the weapon when landing
-	delta = cg.time - cg.landTime;
-	if ( delta < LAND_DEFLECT_TIME ) {
-		origin[2] += cg.landChange*0.25 * delta / LAND_DEFLECT_TIME;
-	} else if ( delta < LAND_DEFLECT_TIME + LAND_RETURN_TIME ) {
-		origin[2] += cg.landChange*0.25 * 
-			(LAND_DEFLECT_TIME + LAND_RETURN_TIME - delta) / LAND_RETURN_TIME;
-	}
-
-#if 0
-	// drop the weapon when stair climbing
-	delta = cg.time - cg.stepTime;
-	if ( delta < STEP_TIME/2 ) {
-		origin[2] -= cg.stepChange*0.25 * delta / (STEP_TIME/2);
-	} else if ( delta < STEP_TIME ) {
-		origin[2] -= cg.stepChange*0.25 * (STEP_TIME - delta) / (STEP_TIME/2);
-	}
-#endif
-
-	// idle drift
-	scale = cg.xyspeed + 40;
-	fracsin = sin( cg.time * 0.001 );
-	angles[ROLL] += scale * fracsin * 0.01;
-	angles[YAW] += scale * fracsin * 0.01;
-	angles[PITCH] += scale * fracsin * 0.01;
+static void CG_SetWeaponModel(refEntity_t* entity,float scale,qhandle_t model,qhandle_t skin){
+	vec3_t minimum;
+	vec3_t maximum;
+	entity->reType = RT_MODEL;
+	entity->hModel = model;
+	entity->customSkin = skin;
+	entity->nonNormalizedAxes = qtrue;
+	VectorScale(entity->axis[0],scale,entity->axis[0]);
+	VectorScale(entity->axis[1],scale,entity->axis[1]);
+	VectorScale(entity->axis[2],scale,entity->axis[2]);
+	if(!cg_drawBBox.value){return;}
+	trap_R_ModelBounds(entity->hModel,minimum,maximum,entity->frame);
+	VectorScale(minimum,scale,minimum);
+	VectorScale(maximum,scale,maximum);
+	CG_DrawBoundingBox(entity->origin,minimum,maximum);
 }
-
-
-/*
-===============
-CG_LightningBolt
-
-Origin will be the exact tag point, which is slightly
-different than the muzzle point used for determining hits.
-The cent should be the non-predicted cent if it is from the player,
-so the endpoint will reflect the simulated strike (lagging the predicted
-angle)
-===============
-*/
-static void CG_LightningBolt( centity_t *cent, vec3_t origin ) {
-	return;
-}
-/*
-===============
-JUHOX: CG_Draw3DLine
-===============
-*/
-void CG_Draw3DLine(const vec3_t start, const vec3_t end, qhandle_t shader) {
-	refEntity_t line;
-
-	//if (DistanceSquared(start, end) < 10*10) return;	
-	memset(&line, 0, sizeof(line));
-	line.reType = RT_LIGHTNING;
-	line.customShader = shader;
-	VectorCopy(start, line.origin);
-	VectorCopy(end, line.oldorigin);
-	trap_R_AddRefEntityToScene(&line);
-}
-
-/*
-===============
-CG_SpawnRailTrail
-
-Origin will be the exact tag point, which is slightly
-different than the muzzle point used for determining hits.
-===============
-*/
-static void CG_SpawnRailTrail( centity_t *cent, vec3_t origin ) {return;}
-
-
-/*
-========================
-CG_AddWeaponWithPowerups
-========================
-*/
-static void CG_AddWeaponWithPowerups( refEntity_t *gun, int powerups ) {}
-
-
-/*
-=============
-CG_AddPlayerWeaponCharge
-
-Used for both the primary and the alternate fire of weapons.
-Used case depends on input.
-=============
-*/
-static void CG_AddPlayerWeaponCharge( refEntity_t *parent, cg_userWeapon_t *weaponGraphics,
-									  refEntity_t *charge, float chargeLvl ) {
-	float				chargeScale;
-	float				chargeDlightScale;
-	
-	// Obtain the scale the charge must have.
-	if (weaponGraphics->chargeGrowth) {
-		// above the end, we use the highest form
-		if (weaponGraphics->chargeEndPct <= chargeLvl) {
-			chargeScale = weaponGraphics->chargeEndsize;
-			chargeDlightScale = weaponGraphics->chargeDlightEndRadius;
-		} else {
-			// inbetween start and end, we work out the value
-			float	PctRange;
-			float	PctVal;
-			float	SizeRange;
-			float	SizeVal;
-					
-			PctRange = weaponGraphics->chargeEndPct - weaponGraphics->chargeStartPct;
-			PctVal = chargeLvl - weaponGraphics->chargeStartPct;
-
-			SizeRange = weaponGraphics->chargeEndsize - weaponGraphics->chargeStartsize;
-			SizeVal = (PctVal / PctRange) * SizeRange;
-			chargeScale = SizeVal + weaponGraphics->chargeStartsize;
-
-			SizeRange = weaponGraphics->chargeDlightEndRadius - weaponGraphics->chargeDlightStartRadius;
-			SizeVal = (PctVal / PctRange) * SizeRange;
-			chargeDlightScale = SizeVal + weaponGraphics->chargeDlightStartRadius;
-		}
-	} else {
-		chargeScale = weaponGraphics->chargeStartsize;
-		chargeDlightScale = weaponGraphics->chargeDlightStartRadius;
-	}
-
-	// Add the charge model or sprite
-
-	VectorCopy( parent->lightingOrigin, charge->lightingOrigin );
+static void CG_AddPlayerWeaponCharge(refEntity_t* parent,cg_userWeapon_t* weaponGraphics,refEntity_t* charge,float progress){
+	float scale = weaponGraphics->chargeStartsize;
+	float lightScale = weaponGraphics->chargeDlightStartRadius;
+	VectorCopy(parent->lightingOrigin,charge->lightingOrigin);
 	charge->shadowPlane = parent->shadowPlane;
 	charge->renderfx = parent->renderfx;
-	if ( ! (weaponGraphics->chargeModel && weaponGraphics->chargeSkin) ) {
-		charge->reType = RT_SPRITE;
-		charge->radius = 4 * chargeScale;
-		charge->rotation = 0;
-		charge->customShader = weaponGraphics->chargeShader;
-	} else {
-		charge->reType = RT_MODEL;
-		charge->hModel = weaponGraphics->chargeModel;
-		charge->customSkin = weaponGraphics->chargeSkin;
-	
-		charge->nonNormalizedAxes = qtrue;
-		VectorScale(charge->axis[0], chargeScale, charge->axis[0]);
-		VectorScale(charge->axis[1], chargeScale, charge->axis[1]);
-		VectorScale(charge->axis[2], chargeScale, charge->axis[2]);
-
-		if(cg_drawBBox.value){
-			vec3_t	mins,maxs;
-			trap_R_ModelBounds( charge->hModel, mins, maxs, charge->frame );
-			VectorScale(mins, chargeScale, mins);
-			VectorScale(maxs, chargeScale, maxs);
-			CG_DrawBoundingBox( charge->origin, mins, maxs );
+	if(weaponGraphics->chargeGrowth){
+		if(weaponGraphics->chargeEndPct <= progress){
+			scale = weaponGraphics->chargeEndsize;
+			lightScale = weaponGraphics->chargeDlightEndRadius;
 		}
-
+		else{
+			float percentRange = weaponGraphics->chargeEndPct - weaponGraphics->chargeStartPct;
+			float sizeRange = weaponGraphics->chargeEndsize - weaponGraphics->chargeStartsize;
+			float percent = progress - weaponGraphics->chargeStartPct;
+			float size = percent / percentRange * sizeRange;
+			scale = size + weaponGraphics->chargeStartsize;
+			sizeRange = weaponGraphics->chargeDlightEndRadius - weaponGraphics->chargeDlightStartRadius;
+			size = percent / percentRange * sizeRange;
+			lightScale = size + weaponGraphics->chargeDlightStartRadius;
+		}
 	}
-
-	trap_R_AddRefEntityToScene( charge );
-
-
-	// add dynamic light
-	if ( chargeDlightScale ) {
-		trap_R_AddLightToScene( charge->origin,
-								100 * chargeDlightScale,
-								weaponGraphics->chargeDlightColor[0],
-								weaponGraphics->chargeDlightColor[1],
-								weaponGraphics->chargeDlightColor[2] );
+	if(!weaponGraphics->chargeModel || !weaponGraphics->chargeSkin){
+		CG_SetWeaponSprite(charge,scale,weaponGraphics->chargeShader);
 	}
+	else{
+		CG_SetWeaponModel(charge,scale,weaponGraphics->chargeModel,weaponGraphics->chargeSkin);
+	}
+	trap_R_AddRefEntityToScene(charge);
+	if(lightScale){
+		trap_R_AddLightToScene(charge->origin,100 * lightScale,weaponGraphics->chargeDlightColor);
+	}
 }
-
-/*
-=============
-CG_AddPlayerWeaponChargeVoices
-
-Used for both the primary and the alternate fire of weapons.
-Used case depends on input.
-=============
-*/
-static void CG_AddPlayerWeaponChargeVoices( centity_t *player, cg_userWeapon_t *weaponGraphics, float curChargeLvl, float prevChargeLvl ) {
-	int i;
-	chargeVoice_t *voice;
-
-	for ( i = MAX_CHARGE_VOICES - 1; i >= 0; i-- ) {
-		voice = &weaponGraphics->chargeVoice[i];
-		if ( voice->voice ) { // no sound; no complex boolean eval
-			if ( (voice->startPct > prevChargeLvl) && (voice->startPct < curChargeLvl) && ( prevChargeLvl < curChargeLvl ) ) {
-				trap_S_StartSound( NULL , player->currentState.number, CHAN_VOICE, voice->voice );
-				break;
-			}
+static void CG_AddPlayerWeaponChargeVoices(centity_t* player,cg_userWeapon_t* weaponGraphics,float currentProgress,float previousProgress){
+	int index = MAX_CHARGE_VOICES-1;
+	for(;index>=0;--index){
+		chargeVoice_t* voice = &weaponGraphics->chargeVoice[index];
+		if(!voice->voice){continue;}
+		if(voice->startPct > previousProgress && voice->startPct < currentProgress && previousProgress < currentProgress){
+			trap_S_StartSound(NULL,player->currentState.number,CHAN_VOICE,voice->voice);
+			break;
 		}
 	}
 }
-
-/*
-=============
-CG_AddPlayerWeaponFlash
-
-Used for both the primary and the alternate fire of weapons.
-Used case depends on input.
-=============
-*/
-static void CG_AddPlayerWeaponFlash( refEntity_t *parent, cg_userWeapon_t *weaponGraphics,
-									  refEntity_t *flash, int flashPowerLevelTotal, int flashPowerLevelCurrent ) {
-	float	flashScale;
-	float	radiusScale;
-
-	if(flashPowerLevelCurrent >= (flashPowerLevelTotal * 2)){
-		flashPowerLevelCurrent = flashPowerLevelTotal * 2;
-	}
-
-	radiusScale = (float)flashPowerLevelCurrent / (float)flashPowerLevelTotal;
-	flashScale = weaponGraphics->flashSize * radiusScale;
-
-	if (radiusScale > 1.0f){
-		radiusScale = 1.0f;
-	}else if(radiusScale < 0.0f){
-		radiusScale = 0.0f;
-	}
-
-	// Add the charge model or sprite
-
-	VectorCopy( parent->lightingOrigin, flash->lightingOrigin );
+static void CG_AddPlayerWeaponFlash(refEntity_t* parent,cg_userWeapon_t* weaponGraphics,refEntity_t* flash,int totalPower,int currentPower){
+	float scale;
+	float radiusScale;
+	VectorCopy(parent->lightingOrigin,flash->lightingOrigin);
 	flash->shadowPlane = parent->shadowPlane;
 	flash->renderfx = parent->renderfx;
-	if ( ! (weaponGraphics->flashModel && weaponGraphics->flashSkin) ) {
-		flash->reType = RT_SPRITE;
-		flash->radius = 4 * flashScale;
-		flash->rotation = 0;
-		flash->customShader = weaponGraphics->flashShader;
-	} else {
-		flash->reType = RT_MODEL;
-		flash->hModel = weaponGraphics->flashModel;
-		flash->customSkin = weaponGraphics->flashSkin;
-	
-		flash->nonNormalizedAxes = qtrue;
-		VectorScale(flash->axis[0], flashScale, flash->axis[0]);
-		VectorScale(flash->axis[1], flashScale, flash->axis[1]);
-		VectorScale(flash->axis[2], flashScale, flash->axis[2]);
-
-		if(cg_drawBBox.value){
-			vec3_t	mins,maxs;
-			trap_R_ModelBounds( flash->hModel, mins, maxs, flash->frame );
-			VectorScale(mins, flashScale, mins);
-			VectorScale(maxs, flashScale, maxs);
-			CG_DrawBoundingBox( flash->origin, mins, maxs );
-		}
+	if(currentPower >= totalPower * 2){currentPower = totalPower * 2;}
+	radiusScale = Com_Clamp(0,1,(float)currentPower / (float)totalPower);
+	scale = weaponGraphics->flashSize * radiusScale;
+	if(!weaponGraphics->flashModel || !weaponGraphics->flashSkin){
+		CG_SetWeaponSprite(flash,scale,weaponGraphics->flashShader);
 	}
-
-	trap_R_AddRefEntityToScene( flash );
-
-
-	// add dynamic light
-	if ( weaponGraphics->flashDlightRadius ) {
-		trap_R_AddLightToScene( flash->origin,
-								100 * weaponGraphics->flashDlightRadius,
-								weaponGraphics->flashDlightColor[0],
-								weaponGraphics->flashDlightColor[1],
-								weaponGraphics->flashDlightColor[2] );
+	else{
+		CG_SetWeaponModel(flash,scale,weaponGraphics->flashModel,weaponGraphics->flashSkin);
 	}
+	trap_R_AddRefEntityToScene(flash);
+	if(weaponGraphics->flashDlightRadius){
+		trap_R_AddLightToScene(flash->origin,100 * weaponGraphics->flashDlightRadius,weaponGraphics->flashDlightColor);
+	}
 }
-
-/*
-====================
-CG_AddPlayerWeapon
-====================
-*/
-void CG_AddPlayerWeapon( refEntity_t *parent, playerState_t *ps, centity_t *cent, int team ) {
-	cg_userWeapon_t		*weaponGraphics;
-	orientation_t		orient;
-	refEntity_t			refEnt;
-	entityState_t		*ent;
-	float				lerp;
-	float				backLerp;
-	int					newLerp;
-	weaponstate_t		weaponState;
-
-	// Set some shorthands
-	ent = &cent->currentState;
-	weaponState = ent->weaponstate;
-	
-	// Any of the charging states
-	if ( weaponState == WEAPON_CHARGING || weaponState == WEAPON_ALTCHARGING ) {
-
-		// Set properties depending on primary or alternate fire
-		if ( weaponState == WEAPON_CHARGING ) {
-			weaponGraphics = CG_FindUserWeaponGraphics(ent->clientNum, ent->weapon);
-
+void CG_AddPlayerWeapon(refEntity_t* parent,centity_t* client){
+	entityState_t* ent = &client->currentState;
+	weaponstate_t weaponState = ent->weaponstate;
+	cg_userWeapon_t* weaponGraphics;
+	orientation_t orient;
+	refEntity_t refEnt;
+	qboolean wasPVS = CG_FrameHist_WasInPVS(ent->number);
+	qboolean newNR = CG_FrameHist_IsWeaponNr(ent->number) != CG_FrameHist_WasWeaponNr(ent->number);
+	qboolean newState = CG_FrameHist_IsWeaponState(ent->number) != CG_FrameHist_WasWeaponState(ent->number);
+	if(weaponState == WEAPON_CHARGING || weaponState == WEAPON_ALTCHARGING){
+		int newLerp;
+		float backLerp;
+		float lerp;
+		if(weaponState == WEAPON_CHARGING){
+			weaponGraphics = CG_FindUserWeaponGraphics(ent->clientNum,ent->weapon);
 			newLerp = ent->charge1.chBase;
-			backLerp = cent->lerpPrim;
-			if ( newLerp < backLerp ) {
-				cent->lerpPrim = newLerp;
-			} else {
-				cent->lerpPrim = (cent->lerpPrim + newLerp ) / 2.0f;
-			}
-
-			lerp = cent->lerpPrim;
-			cent->lerpSec = 0;
-		} else {
+			backLerp = client->lerpPrim;
+			client->lerpPrim = newLerp < backLerp ? newLerp : (client->lerpPrim + newLerp) / 2.0f;
+			lerp = client->lerpPrim;
+			client->lerpSec = 0;
+		}
+		else{
 			weaponGraphics = CG_FindUserWeaponGraphics(ent->clientNum, ent->weapon + ALTWEAPON_OFFSET );
-
 			newLerp = ent->charge2.chBase;
-			backLerp = cent->lerpSec;
-			if ( newLerp < backLerp ) {
-				cent->lerpSec = newLerp;
-			} else {
-				cent->lerpSec = (cent->lerpSec + newLerp ) / 2.0f;
-			}
-
-			lerp = cent->lerpSec;
-			cent->lerpPrim = 0;
+			backLerp = client->lerpSec;
+			client->lerpSec = newLerp < backLerp ? newLerp : (client->lerpSec + newLerp) / 2.0f;
+			lerp = client->lerpSec;
+			client->lerpPrim = 0;
 		}
-
-		// Only bother with anything else if the charge in question is larger than the minimum used for display
-		if ( lerp > weaponGraphics->chargeStartPct ) {			
-
-			// Locate a tag wherever on the model's parts. Don't process further if the tag is not found
-			if (CG_GetTagOrientationFromPlayerEntity( cent, weaponGraphics->chargeTag[0], &orient )) {
-				memset( &refEnt, 0, sizeof(refEnt));
-
-				if ( VectorLength(weaponGraphics->chargeSpin) != 0.0f ) {
-					vec3_t	tempAngles;
-					vec3_t	lerpAxis[3], tempAxis[3];
-					
-					VectorCopy( orient.origin, refEnt.origin );
-					VectorSet( tempAngles, cg.time / 4.0f, cg.time / 4.0f, cg.time / 4.0f );
-					VectorPieceWiseMultiply( tempAngles, weaponGraphics->chargeSpin, tempAngles );
-					AnglesToAxis( tempAngles, lerpAxis );
-
-					AxisClear( refEnt.axis );
-					MatrixMultiply( refEnt.axis, lerpAxis, tempAxis );
-					MatrixMultiply( tempAxis, orient.axis, refEnt.axis );					
-
-				} else {
-
-					VectorCopy( orient.origin, refEnt.origin );
-					AxisCopy( orient.axis, refEnt.axis );
+		if(lerp > weaponGraphics->chargeStartPct){
+			if(CG_GetTagOrientationFromPlayerEntity(client,weaponGraphics->chargeTag[0],&orient)){
+				memset(&refEnt,0,sizeof(refEnt));
+				if(VectorLength(weaponGraphics->chargeSpin)){
+					vec3_t tempAngles;
+					vec3_t lerpAxis[3];
+					vec3_t tempAxis[3];
+					VectorCopy(orient.origin,refEnt.origin);
+					VectorSet(tempAngles,cg.time / 4.0f,cg.time / 4.0f,cg.time / 4.0f);
+					VectorPieceWiseMultiply(tempAngles,weaponGraphics->chargeSpin,tempAngles);
+					AnglesToAxis(tempAngles,lerpAxis);
+					AxisClear(refEnt.axis);
+					MatrixMultiply(refEnt.axis,lerpAxis,tempAxis);
+					MatrixMultiply(tempAxis,orient.axis,refEnt.axis);
 				}
-
-				CG_AddPlayerWeaponCharge( parent, weaponGraphics, &refEnt, lerp );
+				else{
+					VectorCopy(orient.origin,refEnt.origin);
+					AxisCopy(orient.axis,refEnt.axis);
+				}
+				CG_AddPlayerWeaponCharge(parent,weaponGraphics,&refEnt,lerp);
 			}
 		}
-		
-		if ( weaponGraphics->chargeLoopSound ) {
-			trap_S_AddLoopingSound( ent->number, cent->lerpOrigin, vec3_origin, weaponGraphics->chargeLoopSound );
+		if(weaponGraphics->chargeLoopSound){
+			trap_S_AddLoopingSound(ent->number,client->lerpOrigin,vec3_origin,weaponGraphics->chargeLoopSound);
 		}
-
-		CG_AddPlayerWeaponChargeVoices( cent, weaponGraphics, lerp, backLerp );
-
-		// Set up any charging particle systems
-		if ( weaponGraphics->chargeParticleSystem[0] ) {
+		CG_AddPlayerWeaponChargeVoices(client,weaponGraphics,lerp,backLerp);
+		if(weaponGraphics->chargeParticleSystem[0]){
 			// If the entity wasn't previously in the PVS, if the weapon nr switched, or if the weaponstate switched
 			// we need to start a new system
-			if ( !CG_FrameHist_WasInPVS(ent->number) ||
-				 CG_FrameHist_IsWeaponNr(ent->number) != CG_FrameHist_WasWeaponNr(ent->number) ||
-				 CG_FrameHist_IsWeaponState(ent->number) != CG_FrameHist_WasWeaponState(ent->number) ) {
-				PSys_SpawnCachedSystem( weaponGraphics->chargeParticleSystem, cent->lerpOrigin, NULL, cent, weaponGraphics->chargeTag[0], qfalse, qtrue );
+			if(!wasPVS || newNR || newState){
+				PSys_SpawnCachedSystem(weaponGraphics->chargeParticleSystem,client->lerpOrigin,NULL,client,weaponGraphics->chargeTag[0],qfalse,qtrue);
 			}
-		}		
-
-	// Any of the firing or guiding states
-	} else if ( weaponState == WEAPON_GUIDING || weaponState == WEAPON_ALTGUIDING || weaponState == WEAPON_FIRING || weaponState == WEAPON_ALTFIRING ) { 
-
-		// Set properties depending on primary or alternate fire
-		if ( weaponState == WEAPON_GUIDING || weaponState == WEAPON_FIRING ) {
-			weaponGraphics = CG_FindUserWeaponGraphics(ent->clientNum, ent->weapon );
-		} else {
-			weaponGraphics = CG_FindUserWeaponGraphics(ent->clientNum, ent->weapon + ALTWEAPON_OFFSET );
 		}
-
-		// Locate a tag wherever on the model's parts. Don't process further if the tag is not found
-		if (CG_GetTagOrientationFromPlayerEntity( cent, weaponGraphics->chargeTag[0], &orient )) {
-			memset( &refEnt, 0, sizeof(refEnt));
-
-			VectorCopy( orient.origin, refEnt.origin );
-			AxisCopy( orient.axis, refEnt.axis );
-			
-			CG_AddPlayerWeaponFlash( parent, weaponGraphics, &refEnt, ent->attackPowerTotal, ent->attackPowerCurrent );
+	}
+	else if(weaponState == WEAPON_GUIDING || weaponState == WEAPON_ALTGUIDING || weaponState == WEAPON_FIRING || weaponState == WEAPON_ALTFIRING){
+		int index = weaponState == WEAPON_GUIDING || weaponState == WEAPON_FIRING ? ent->weapon : ent->weapon + ALTWEAPON_OFFSET;
+		weaponGraphics = CG_FindUserWeaponGraphics(ent->clientNum,index);
+		if(CG_GetTagOrientationFromPlayerEntity(client,weaponGraphics->chargeTag[0],&orient)){
+			memset(&refEnt,0,sizeof(refEnt));
+			VectorCopy(orient.origin,refEnt.origin);
+			AxisCopy(orient.axis,refEnt.axis);
+			CG_AddPlayerWeaponFlash(parent,weaponGraphics,&refEnt,ent->attackPowerTotal,ent->attackPowerCurrent);
 		}
-
-		if ( weaponGraphics->firingSound ) {
-			trap_S_AddLoopingSound( ent->number, cent->lerpOrigin, vec3_origin, weaponGraphics->firingSound );
+		if(weaponGraphics->firingSound){
+			trap_S_AddLoopingSound(ent->number,client->lerpOrigin,vec3_origin,weaponGraphics->firingSound);
 		}
-
-		// Set up any firing particle systems
-		if ( weaponGraphics->firingParticleSystem[0] ) {
+		if(weaponGraphics->firingParticleSystem[0]){
 			// If the entity wasn't previously in the PVS, if the weapon nr switched, or if the weaponstate switched
 			// we need to start a new system
-			if ( !CG_FrameHist_WasInPVS(ent->number) ||
-				 CG_FrameHist_IsWeaponNr(ent->number) != CG_FrameHist_WasWeaponNr(ent->number) ||
-				 CG_FrameHist_IsWeaponState(ent->number) != CG_FrameHist_WasWeaponState(ent->number) ) {
-				PSys_SpawnCachedSystem( weaponGraphics->firingParticleSystem, cent->lerpOrigin, NULL, cent, weaponGraphics->chargeTag[0], qfalse, qtrue );
+			if(!wasPVS || newNR || newState){
+				PSys_SpawnCachedSystem(weaponGraphics->firingParticleSystem,client->lerpOrigin,NULL,client,weaponGraphics->chargeTag[0],qfalse,qtrue);
 			}
 		}
 	}
 }
-
 /*
-==============
-CG_AddViewWeapon
-
-Add the weapon, and flash for the player's view
-==============
-*/
-void CG_AddViewWeapon( playerState_t *ps ) {
-
-	return;
-	
-/*
-	refEntity_t	hand;
-	centity_t	*cent;
-	clientInfo_t	*ci;
-	float		fovOffset;
-	vec3_t		angles;
-	weaponInfo_t	*weapon;
-
-
-
-	if ( ps->persistant[PERS_TEAM] == TEAM_SPECTATOR ) {
-		return;
-	}
-
-	if ( ps->pm_type == PM_INTERMISSION ) {
-		return;
-	}
-
-	// no gun if in third person view or a camera is active
-	//if ( cg.renderingThirdPerson || cg.cameraMode) {
-	if ( cg.renderingThirdPerson ) {
-		return;
-	}
-
-
-	// allow the gun to be completely removed
-	if ( !cg_drawGun.integer ) {
-		vec3_t		origin;
-
-		if ( cg.predictedPlayerState.eFlags & EF_FIRING ) {
-			// special hack for lightning gun...
-			VectorCopy( cg.refdef.vieworg, origin );
-			VectorMA( origin, -8, cg.refdef.viewaxis[2], origin );
-			CG_LightningBolt( &cg_entities[ps->clientNum], origin );
-		}
-		return;
-	}
-
-	// don't draw if testing a gun model
-	if ( cg.testGun ) {
-		return;
-	}
-
-	// drop gun lower at higher fov
-	if ( cg_fov.integer > 90 ) {
-		fovOffset = -0.2 * ( cg_fov.integer - 90 );
-	} else {
-		fovOffset = 0;
-	}
-
-	cent = &cg.predictedPlayerEntity;	// &cg_entities[cg.snap->ps.clientNum];
-	CG_RegisterWeapon( ps->weapon );
-	weapon = &cg_weapons[ ps->weapon ];
-
-	memset (&hand, 0, sizeof(hand));
-
-	// set up gun position
-	CG_CalculateWeaponPosition( hand.origin, angles );
-
-	VectorMA( hand.origin, cg_gun_x.value, cg.refdef.viewaxis[0], hand.origin );
-	VectorMA( hand.origin, cg_gun_y.value, cg.refdef.viewaxis[1], hand.origin );
-	VectorMA( hand.origin, (cg_gun_z.value+fovOffset), cg.refdef.viewaxis[2], hand.origin );
-
-	AnglesToAxis( angles, hand.axis );
-
-	// map torso animations to weapon animations
-	if ( cg_gun_frame.integer ) {
-		// development tool
-		hand.frame = hand.oldframe = cg_gun_frame.integer;
-		hand.backlerp = 0;
-	} else {
-		// get clientinfo for animation map
-		ci = &cgs.clientinfo[ cent->currentState.clientNum ];
-		hand.frame = CG_MapTorsoToWeaponFrame( ci, cent->pe.torso.frame );
-		hand.oldframe = CG_MapTorsoToWeaponFrame( ci, cent->pe.torso.oldFrame );
-		hand.backlerp = cent->pe.torso.backlerp;
-	}
-
-	hand.hModel = weapon->handsModel;
-	hand.renderfx = RF_DEPTHHACK | RF_FIRST_PERSON | RF_MINLIGHT;
-
-	// add everything onto the hand
-	CG_AddPlayerWeapon( &hand, ps, &cg.predictedPlayerEntity, ps->persistant[PERS_TEAM] );
-*/
-}
-
-/*
 ==============================================================================
-
 WEAPON SELECTION
-
 ==============================================================================
 */
-
-static void CG_DrawWeaponSelectQuarterFan( void ) {
-	int				i;
-	int				bits;
-	int				count;
-	int				x, y;
-	int				textX, textY;
-	int				iconsPerLine, iconW, iconH;
-	int				rootX, rootY;
-	int				startOffset, lineOffset;
-	float			startAngle, endAngle;
-	float			angleUnit;
-	char			name[MAX_WEAPONNAME * 2 + 4]; // Need a little more leeway
-	float			*color;
-	cg_userWeapon_t	*weaponInfo;
-	cg_userWeapon_t	*alt_weaponInfo;
-
-	color = CG_FadeColor( cg.weaponSelectTime, WEAPON_SELECT_TIME, 200 );
-	if ( !color ) {
+static void CG_DrawWeaponSelectHorCenterBar(void){
+	int i;
+	int statBits = cg.snap->ps.stats[stSkills];
+	float* color = CG_FadeColor(cg.weaponSelectTime,WEAPON_SELECT_TIME,200);
+	vec2_t position = {70,418};
+	cg_userWeapon_t* weaponInfo;
+	cg_userWeapon_t* alt_weaponInfo;
+	if(!color){
 		cg.drawWeaponBar = 0;
 		return;
 	}
-	trap_R_SetColor( color );
-
-	textX = 110; textY = 380;
-
-	rootX = 64;	rootY = 424;
-	iconsPerLine = 3; iconW = 32; iconH = 32;
-	startAngle = DEG2RAD(-20); endAngle = DEG2RAD(40);
-	startOffset = 80; lineOffset = 40;
-
-	if (iconsPerLine != 1) {
-		angleUnit = (endAngle - startAngle) / (iconsPerLine - 1);
-	} else {
-		angleUnit = 0;
+	trap_R_SetColor(color);
+	for(i=1;i<MAX_PLAYERWEAPONS;++i){
+		qboolean exists = statBits & (1 << i);
+		qboolean usable = cg.snap->ps.powerups[PW_SKILLS] & (1 << (i-1));
+		if(!exists || !usable){continue;}
+		weaponInfo = CG_FindUserWeaponGraphics(cg.snap->ps.clientNum,i);
+		CG_DrawPic(qfalse,position[0],position[1],24,24,weaponInfo->weaponIcon);
+		if(i == cg.weaponSelect){CG_DrawPic(qfalse,position[0] - 4,position[1] - 4, 32,32,cgs.media.selectShader);}
+		position[0] += 30;
 	}
-	
-	bits = cg.snap->ps.stats[ stSkills ];
-	count = 0;
-	for ( i = 1 ; i < 16 ; i++ ) {
-		if ( !( bits & ( 1 << i ) ) ) {
-			continue;
+	weaponInfo = CG_FindUserWeaponGraphics(cg.snap->ps.clientNum,cg.weaponSelect);
+	alt_weaponInfo = CG_FindUserWeaponGraphics(cg.snap->ps.clientNum,ALTWEAPON_OFFSET + cg.weaponSelect);
+	if(weaponInfo->weaponName[0]){
+		// Need a little more leeway
+		char name[MAX_WEAPONNAME * 2 + 4];
+		Com_sprintf(name,sizeof(name),"%s",weaponInfo->weaponName);
+		if(alt_weaponInfo->weaponName[0]){
+			strcat(name,va(" / %s",alt_weaponInfo->weaponName));
 		}
-
-		weaponInfo = CG_FindUserWeaponGraphics( cg.snap->ps.clientNum, i );
-
-		// set position
-		x = rootX - (iconW / 2) +
-			sin(startAngle + angleUnit * (count % 3)) * (startOffset + lineOffset * (count / 3));
-		y = rootY - (iconH / 2) +
-			-1 * cos(startAngle + angleUnit * (count % 3)) * (startOffset + lineOffset * (count / 3));
-		// draw weapon icon
-		if ( weaponInfo->weaponIcon ) {
-			CG_DrawPic(qfalse, x, y, 32, 32, weaponInfo->weaponIcon );
-		}
-
-		if ( i == cg.weaponSelect ) {
-			CG_DrawPic(qfalse, x-4, y-4, 40, 40, cgs.media.selectShader );
-		}
-		count++;
+		CG_DrawSmallStringColor(6,position[1] - 30,name,color);
 	}
-
-	weaponInfo = CG_FindUserWeaponGraphics( cg.snap->ps.clientNum, cg.weaponSelect );
-	alt_weaponInfo = CG_FindUserWeaponGraphics ( cg.snap->ps.clientNum, ALTWEAPON_OFFSET + cg.weaponSelect);
-
-	// draw the selected name
-	if ( weaponInfo->weaponName[0] != 0 ) {
-
-		if ( alt_weaponInfo->weaponName[0] != 0 ) {
-			Com_sprintf( name, sizeof(name), "%s / %s", weaponInfo->weaponName, alt_weaponInfo->weaponName );
-		} else {
-			Com_sprintf( name, sizeof(name), "%s", weaponInfo->weaponName );
-		}
-
-		CG_DrawMediumStringColor(textX, textY, name, color);
-	}
-	trap_R_SetColor( NULL );
-	
+	trap_R_SetColor(NULL);
 }
-
-/*
-===============================
-CG_DrawWeaponSelectHorCenterBar
-===============================
-*/
-static void CG_DrawWeaponSelectHorCenterBar( void ) {
-	int		i;
-	int		bits;
-	int		count;
-	int		x, y, w;
-	char	name[MAX_WEAPONNAME * 2 + 4]; // Need a little more leeway
-	float	*color;
-	cg_userWeapon_t	*weaponInfo;
-	cg_userWeapon_t	*alt_weaponInfo;
-
-	color = CG_FadeColor( cg.weaponSelectTime, WEAPON_SELECT_TIME, 200 );
-	if ( !color ) {
-		cg.drawWeaponBar = 0;
-		return;
-	}
-
-	trap_R_SetColor( color );
-
-	// count the number of weapons owned
-	bits = cg.snap->ps.stats[ stSkills ];
-	count = 0;
-	for ( i = 1 ; i < 16 ; i++ ) {
-		if ( bits & ( 1 << i ) ) {
-			count++;
-		}
-	}
-
-	x = 164 - count * 15;
-	y = 418;
-
-	for ( i = 1 ; i < 16 ; i++ ) {
-		qboolean usable;
-		if ( !( bits & ( 1 << i ) ) ) {
-			continue;
-		}
-
-		//CG_RegisterWeapon( i );
-
-		weaponInfo = CG_FindUserWeaponGraphics( cg.snap->ps.clientNum, i );
-		usable = qfalse;
-		// draw weapon icon
-		//CG_DrawPic(qfalse, x, y, 32, 32, cg_weapons[i].weaponIcon );
-		if(i == 1 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL1){usable = qtrue;}
-		if(i == 2 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL2){usable = qtrue;}
-		if(i == 3 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL3){usable = qtrue;}
-		if(i == 4 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL4){usable = qtrue;}
-		if(i == 5 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL5){usable = qtrue;}
-		if(i == 6 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL6){usable = qtrue;}
-		if(!usable){
-			continue;
-		}
-		CG_DrawPic(qfalse, x, y, 24, 24, weaponInfo->weaponIcon );
-		if ( i == cg.weaponSelect ) {
-			CG_DrawPic(qfalse, x-4, y-4, 32, 32, cgs.media.selectShader );
-		}
-		x += 30;
-
-	}
-
-	weaponInfo = CG_FindUserWeaponGraphics( cg.snap->ps.clientNum, cg.weaponSelect );
-	alt_weaponInfo = CG_FindUserWeaponGraphics ( cg.snap->ps.clientNum, ALTWEAPON_OFFSET + cg.weaponSelect);
-
-	// draw the selected name
-	if ( weaponInfo->weaponName ) {
-
-		if ( alt_weaponInfo->weaponName ) {
-			Com_sprintf( name, sizeof(name), "%s / %s", weaponInfo->weaponName, alt_weaponInfo->weaponName );
-		} else {
-			Com_sprintf( name, sizeof(name), "%s", weaponInfo->weaponName );
-		}
-
-		w = CG_DrawStrlen( name ) * MEDIUMCHAR_WIDTH; //BIGCHAR_WIDTH;
-		x = ( SCREEN_WIDTH - w ) / 2;
-		//CG_DrawSmallStringColor(6, y - 30, name, color);
-	}
-
-	trap_R_SetColor( NULL );
-
-}
-
-void CG_DrawWeaponSelect( void ) {
+void CG_DrawWeaponSelect(void){
 	cg.itemPickupTime = 0;
-	if(cg.drawWeaponBar == 1)
-	{
-		CG_DrawWeaponSelectHorCenterBar();
-		//CG_DrawWeaponSelectQuarterFan();
-	}
+	if(cg.drawWeaponBar == 1){CG_DrawWeaponSelectHorCenterBar();}
 }
-
-
-/*
-===============
-CG_WeaponSelectable
-===============
-*/
-static qboolean CG_WeaponSelectable( int i ) {
-	qboolean usable;
-	usable = qfalse;
-	if ( ! (cg.snap->ps.stats[ stSkills ] & ( 1 << i ) ) ) {
-		return qfalse;
-	}
-	if(i == 1 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL1){usable = qtrue;}
-	if(i == 2 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL2){usable = qtrue;}
-	if(i == 3 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL3){usable = qtrue;}
-	if(i == 4 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL4){usable = qtrue;}
-	if(i == 5 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL5){usable = qtrue;}
-	if(i == 6 && cg.snap->ps.powerups[PW_SKILLS] & USABLE_SKILL6){usable = qtrue;}
-	if(!usable){return qfalse;}
-	return qtrue;
-}
-
-/*
-===============
-CG_NextWeapon_f
-===============
-*/
-void CG_NextWeapon_f( void ) {
-	if ( !cg.snap || cg.snap->ps.bitFlags & usingMelee ) {
-		return;
-	}
-	if ( cg.snap->ps.pm_flags & PMF_FOLLOW ) {
-		return;
-	}
+void CG_NextWeapon_f(void){
+	if(!cg.snap || cg.snap->ps.bitFlags & usingMelee){return;}
+	if(cg.snap->ps.pm_flags & PMF_FOLLOW){return;}
 	cg.weaponSelectionMode = 2;
 	cg.weaponSelectTime = cg.time;
 }
-
-/*
-===============
-CG_PrevWeapon_f
-===============
-*/
-void CG_PrevWeapon_f( void ) {
-	if ( !cg.snap || cg.snap->ps.bitFlags & usingMelee ) {
-		return;
-	}
-	if ( cg.snap->ps.pm_flags & PMF_FOLLOW ) {
-		return;
-	}
+void CG_PrevWeapon_f(void){
+	if(!cg.snap || cg.snap->ps.bitFlags & usingMelee){return;}
+	if(cg.snap->ps.pm_flags & PMF_FOLLOW){return;}
 	cg.weaponSelectionMode = 1;
 	cg.weaponSelectTime = cg.time;
 }
-
-
-
-/*
-===============
-CG_Weapon_f
-===============
-*/
-void CG_Weapon_f( void ) {
-	int		num;
-
-	if ( !cg.snap ) {
-		return;
-	}
-	if ( cg.snap->ps.pm_flags & PMF_FOLLOW ) {
-		return;
-	}
-	num = atoi( CG_Argv( 1 ) );
-
-	if ( num < 1 || num > 15 ) {
-		return;
-	}
+void CG_Weapon_f(void){
+	int num = atoi(CG_Argv(1));
+	if(!cg.snap){return;}
+	if(cg.snap->ps.pm_flags & PMF_FOLLOW){return;}
+	if(num < 1 || num > 15){return;}
 	cg.weaponSelectTime = cg.time;
 	cg.weaponDesired = num;
 	cg.weaponSelectionMode = 3;
 }
-
-	/*
-===================================================================================================
-
+/*
+==========================================================
 WEAPON EVENTS
-
-===================================================================================================
+==========================================================
 */
-
 /*
 ================
 CG_FireWeapon
-
 Caused by an EV_FIRE_WEAPON event
 ================
 */
-void CG_FireWeapon( centity_t *cent, qboolean altFire ) {
-	cg_userWeapon_t		*weaponGraphics;
-	entityState_t		*ent;
-	int					c, weapNr;
-
-	ent = &cent->currentState;
-
-	if ( ent->weapon == WP_NONE ) {
-		return;
-	}
-
-	// Set the muzzle flash weapon Nr
-	if ( altFire ) {
-		weapNr = ent->weapon + ALTWEAPON_OFFSET;
-	} else {
-		weapNr = ent->weapon;
-	}
+void CG_FireWeapon(centity_t* client,qboolean altFire){
+	cg_userWeapon_t* weaponGraphics;
+	entityState_t* ent = &client->currentState;
+	int maxSounds = 0;
+	int maxVoices = 0;
+	int weapNr;
+	if(ent->weapon == WP_NONE){return;}
+	weapNr = altFire ? ent->weapon + ALTWEAPON_OFFSET : ent->weapon;
 	weaponGraphics = CG_FindUserWeaponGraphics(ent->clientNum, weapNr );
-	
 	// mark the entity as muzzle flashing, so when it is added it will
 	// append the flash to the weapon model.
-	cent->muzzleFlashTime = cg.time;
-
-	if ( weaponGraphics->flashParticleSystem[0] ) {
-		PSys_SpawnCachedSystem( weaponGraphics->flashParticleSystem, cent->lerpOrigin, NULL, cent, weaponGraphics->chargeTag[0], qfalse, qfalse );
+	client->muzzleFlashTime = cg.time;
+	if(weaponGraphics->flashParticleSystem[0]){
+		PSys_SpawnCachedSystem(weaponGraphics->flashParticleSystem,client->lerpOrigin,NULL,client,weaponGraphics->chargeTag[0],qfalse,qfalse);
 	}
-
-	// play a sound
-	for ( c = 0 ; c < 4 ; c++ ) {
-		if ( weaponGraphics->flashSound[c] == 0 ) {
-			break;
-		}
+	for(;maxSounds<MAX_FLASH_SOUNDS;++maxSounds){
+		if(!weaponGraphics->flashSound[maxSounds]){break;}
 	}
-	
-	if ( c > 0 ) {
-		c = rand() % c;
-		if ( weaponGraphics->flashSound[c] )
-		{
-			trap_S_StartSound( NULL , ent->number, CHAN_WEAPON, weaponGraphics->flashSound[c] );
-		}
+	if(maxSounds > 0){
+		trap_S_StartSound(NULL,ent->number,CHAN_WEAPON,weaponGraphics->flashSound[rand()%maxSounds]);
 	}
-
-	for ( c = 0 ; c < 4 ; c++ ) {
-		if ( weaponGraphics->voiceSound[c] == 0 ) {
-			break;
-		}
+	for(;maxVoices<MAX_FLASH_VOICES;++maxVoices){
+		if(!weaponGraphics->voiceSound[maxVoices]){break;}
 	}
-	
-	if ( c > 0 ) {
-		c = rand() % c;
-		if ( weaponGraphics->voiceSound[c] )
-		{
-			trap_S_StartSound( NULL , ent->number, CHAN_WEAPON, weaponGraphics->voiceSound[c] );
-		}
+	if(maxVoices > 0){
+		trap_S_StartSound(NULL,ent->number,CHAN_WEAPON,weaponGraphics->voiceSound[rand()%maxVoices]);
 	}
-
-
-
 }
-
 /*
-==================
-CG_UserRailTrail
-==================
-Caused by an EV_RAILTRAIL event
-*/
-void CG_UserRailTrail( int weapon, int clientNum, vec3_t start, vec3_t end) {
-	cg_userWeapon_t		*weaponGraphics;
-	localEntity_t		*le;
-	refEntity_t			*re;
-	
-	weaponGraphics = CG_FindUserWeaponGraphics( clientNum, weapon );
-
-	if ( !weaponGraphics->missileTrailShader ) {
-		return;
-	}
-
-	le = CG_AllocLocalEntity();
-	re = &le->refEntity;
- 
-	le->leType = LE_FADE_RGB;
-	le->startTime = cg.time;
-	le->endTime = cg.time + cg_railTrailTime.value;
-	le->lifeRate = 1.0 / (le->endTime - le->startTime);
- 
-	re->shaderTime = cg.time / 1000.0f;
-	re->reType = RT_RAIL_CORE;
-	re->customShader = weaponGraphics->missileTrailShader;
- 
-	VectorCopy(start, re->origin);
-	VectorCopy(end, re->oldorigin);
- 
-	re->shaderRGBA[0] = 255;
-    re->shaderRGBA[1] = 255;
-    re->shaderRGBA[2] = 255;
-    re->shaderRGBA[3] = 255;
-
-	le->color[0] = 0.75;
-	le->color[1] = 0.75;
-	le->color[2] = 0.75;
-	le->color[3] = 1.0f;
-
-	AxisClear( re->axis );
- 
-	/*
-	// nudge the rail down just a tiny bit
-	re->origin[2] -=8
-	re->oldorigin[2] -= 8;
-	*/
-}
-
-
-/*
 ======================
 CG_UserMissileHitWall
 ======================
 Caused by an EV_MISSILE_MISS event
 */
-void CG_UserMissileHitWall( int weapon, int clientNum, int powerups, int number, vec3_t origin, vec3_t dir, qboolean inAir ) {
-	cg_userWeapon_t		*weaponGraphics;
+void CG_UserMissileHitWall(int weapon,int clientNum,int powerups,int number,vec3_t origin,vec3_t dir,qboolean inAir){
+	cg_userWeapon_t* weaponGraphics = CG_FindUserWeaponGraphics(clientNum,weapon);
 	vec3_t end;
 	trace_t tr;
-	//qhandle_t			mark;
-	int					c;
-
-	weaponGraphics = CG_FindUserWeaponGraphics( clientNum, weapon );
-	//mark = cgs.media.burnMarkShader;
-
-	
-	// play an explosion sound
-	for ( c = 0 ; c < 4 ; c++ ) {
-		if ( !weaponGraphics->explosionSound[c] ) {
-			break;
-		}
+	int maxSounds = 0;
+	for(;maxSounds<MAX_EXPLOSION_SOUNDS;++maxSounds){
+		if(!weaponGraphics->explosionSound[maxSounds]){break;}
 	}
-	if ( c > 0 ) {
-		c = rand() % c;
-		if ( weaponGraphics->explosionSound[c] )
-		{
-			trap_S_StartSound( origin, ENTITYNUM_WORLD, CHAN_AUTO, weaponGraphics->explosionSound[c] );
+	if(maxSounds>0){
+		maxSounds = rand() % maxSounds;
+		if(weaponGraphics->explosionSound[maxSounds]){
+			trap_S_StartSound(origin,ENTITYNUM_WORLD,CHAN_AUTO,weaponGraphics->explosionSound[maxSounds]);
 		}
 	}
-
-	// Create Explosion
-	CG_MakeUserExplosion( origin, dir, weaponGraphics, powerups, number);
-
-	if ( !inAir ) {
+	CG_MakeUserExplosion(origin,dir,weaponGraphics,powerups,number);
+	if(!inAir){
 		vec3_t tempAxis[3];
-		VectorNormalize2( dir, tempAxis[0] );
-
-		MakeNormalVectors( tempAxis[0], tempAxis[1], tempAxis[2] );
-
-		VectorCopy(origin, end);
+		VectorNormalize2(dir,tempAxis[0]);
+		MakeNormalVectors(tempAxis[0],tempAxis[1],tempAxis[2]);
+		VectorCopy(origin,end);
 		end[2] -= 64;
-		CG_Trace( &tr, origin, NULL, NULL, end, -1, MASK_PLAYERSOLID );
-		
-		if (!weaponGraphics->noRockDebris){
-			if (cg_particlesQuality.value == 2) {
-				if (tr.surfaceFlags & SURF_METALSTEPS){
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				} else if (tr.surfaceFlags & SURF_FLESH){
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				} else if (tr.surfaceFlags & SURF_DUST){
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				} else {
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebris", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				}
-			}else if (cg_particlesQuality.value == 1){
-				if (tr.surfaceFlags & SURF_METALSTEPS){
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				} else if (tr.surfaceFlags & SURF_FLESH){
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				} else if (tr.surfaceFlags & SURF_DUST){
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				} else {
-					if(weaponGraphics->explosionSize <= 10){
-						PSys_SpawnCachedSystem( "SmallExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 25){
-						PSys_SpawnCachedSystem( "NormalExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else if(weaponGraphics->explosionSize <= 50){
-						PSys_SpawnCachedSystem( "LargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}else{
-						PSys_SpawnCachedSystem( "ExtraLargeExplosionDebrisLow", origin, tempAxis, NULL, NULL, qfalse, qfalse );
-					}
-				}
-			}
+		CG_Trace(&tr,origin,NULL,NULL,end,-1,MASK_PLAYERSOLID);
+		if(!weaponGraphics->noRockDebris){
+			char particles[MAX_QPATH] = "ExtraLarge";
+			if(weaponGraphics->explosionSize <= 10){strcat(particles,"Small");}
+			else if(weaponGraphics->explosionSize <= 25){strcat(particles,"Normal");}
+			else if(weaponGraphics->explosionSize <= 50){strcat(particles,"Large");}
+			strcat(particles,"ExplosionDebris");
+			if(cg_particlesQuality.value == 1){strcat(particles,"Low");}
 		}
-
-		if (weaponGraphics->markSize && weaponGraphics->markShader) {
-			// Draw Impactmark
-			CG_ImpactMark( weaponGraphics->markShader, origin, dir, random()*360, 1,1,1,1, qfalse,60, qfalse );
+		if(weaponGraphics->markSize && weaponGraphics->markShader){
+			CG_ImpactMark(weaponGraphics->markShader,origin,dir,random() * 360,1,1,1,1,qfalse,60,qfalse);
 		}
 	}
-
-	
 /* NOTE: Find another way of doing this in the new system...
 	if ( weaponGraphics->missileTrailFunc == CG_TrailFunc_StraightBeam ||
 		 weaponGraphics->missileTrailFunc == CG_TrailFunc_SpiralBeam ) {
@@ -1177,125 +343,8 @@
 		CG_CreateStraightBeamFade( cgs.clientinfo[ clientNum ].weaponTagPos0, origin, weaponGraphics);
 	}
 */
-
 }
-
-void CG_UserMissileHitPlayer( int weapon, int clientNum, int powerups, int number, vec3_t origin, vec3_t dir, int entityNum ) {
-	CG_Bleed( origin, entityNum );
-	CG_UserMissileHitWall( weapon, clientNum, powerups, number, origin, dir, qtrue );
+void CG_UserMissileHitPlayer(int weapon,int clientNum,int powerups,int number,vec3_t origin,vec3_t dir,int entityNum){
+	CG_Bleed(origin,entityNum);
+	CG_UserMissileHitWall(weapon,clientNum,powerups,number,origin,dir,qtrue);
 }
-/*
-===============
-CG_Tracer
-===============
-*/
-void CG_Tracer( vec3_t source, vec3_t dest ) {
-	vec3_t		forward, right;
-	polyVert_t	verts[4];
-	vec3_t		line;
-	float		len, begin, end;
-	vec3_t		start, finish;
-	vec3_t		midpoint;
-
-	// tracer
-	VectorSubtract( dest, source, forward );
-	len = VectorNormalize( forward );
-
-	// start at least a little ways from the muzzle
-	if ( len < 100 ) {
-		return;
-	}
-	begin = 50 + random() * (len - 60);
-	end = begin + cg_tracerLength.value;
-	if ( end > len ) {
-		end = len;
-	}
-	VectorMA( source, begin, forward, start );
-	VectorMA( source, end, forward, finish );
-
-	line[0] = DotProduct( forward, cg.refdef.viewaxis[1] );
-	line[1] = DotProduct( forward, cg.refdef.viewaxis[2] );
-
-	VectorScale( cg.refdef.viewaxis[1], line[1], right );
-	VectorMA( right, -line[0], cg.refdef.viewaxis[2], right );
-	VectorNormalize( right );
-
-	VectorMA( finish, cg_tracerWidth.value, right, verts[0].xyz );
-	verts[0].st[0] = 0;
-	verts[0].st[1] = 1;
-	verts[0].modulate[0] = 255;
-	verts[0].modulate[1] = 255;
-	verts[0].modulate[2] = 255;
-	verts[0].modulate[3] = 255;
-
-	VectorMA( finish, -cg_tracerWidth.value, right, verts[1].xyz );
-	verts[1].st[0] = 1;
-	verts[1].st[1] = 0;
-	verts[1].modulate[0] = 255;
-	verts[1].modulate[1] = 255;
-	verts[1].modulate[2] = 255;
-	verts[1].modulate[3] = 255;
-
-	VectorMA( start, -cg_tracerWidth.value, right, verts[2].xyz );
-	verts[2].st[0] = 1;
-	verts[2].st[1] = 1;
-	verts[2].modulate[0] = 255;
-	verts[2].modulate[1] = 255;
-	verts[2].modulate[2] = 255;
-	verts[2].modulate[3] = 255;
-
-	VectorMA( start, cg_tracerWidth.value, right, verts[3].xyz );
-	verts[3].st[0] = 0;
-	verts[3].st[1] = 0;
-	verts[3].modulate[0] = 255;
-	verts[3].modulate[1] = 255;
-	verts[3].modulate[2] = 255;
-	verts[3].modulate[3] = 255;
-
-	trap_R_AddPolyToScene( cgs.media.tracerShader, 4, verts );
-
-	midpoint[0] = ( start[0] + finish[0] ) * 0.5;
-	midpoint[1] = ( start[1] + finish[1] ) * 0.5;
-	midpoint[2] = ( start[2] + finish[2] ) * 0.5;
-
-}
-
-
-/*
-======================
-CG_CalcMuzzlePoint
-======================
-*/
-static qboolean	CG_CalcMuzzlePoint( int entityNum, vec3_t muzzle ) {
-	vec3_t		forward;
-	centity_t	*cent;
-	int			anim;
-
-	if ( entityNum == cg.snap->ps.clientNum ) {
-		VectorCopy( cg.snap->ps.origin, muzzle );
-		muzzle[2] += cg.snap->ps.viewheight;
-		AngleVectors( cg.snap->ps.viewangles, forward, NULL, NULL );
-		VectorMA( muzzle, 14, forward, muzzle );
-		return qtrue;
-	}
-
-	cent = &cg_entities[entityNum];
-	if ( !cent->currentValid ) {
-		return qfalse;
-	}
-
-	VectorCopy( cent->currentState.pos.trBase, muzzle );
-
-	AngleVectors( cent->currentState.apos.trBase, forward, NULL, NULL );
-//	anim = cent->currentState.legsAnim & ~ANIM_TOGGLEBIT;
-//	if ( anim == ANIM_WALKCR || anim == ANIM_IDLECR ) {
-//		muzzle[2] += CROUCH_VIEWHEIGHT;
-//	} else {
-		muzzle[2] += DEFAULT_VIEWHEIGHT;
-//	}
-
-	VectorMA( muzzle, 14, forward, muzzle );
-
-	return qtrue;
-
-}
